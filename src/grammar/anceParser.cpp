
// Generated from ./src/grammar/ance.g4 by ANTLR 4.10.1

#include "anceVisitor.h"

#include "anceParser.h"

using namespace antlrcpp;

using namespace antlr4;

namespace
{

    struct AnceParserStaticData final {
        AnceParserStaticData(std::vector<std::string> ruleNames,
                             std::vector<std::string> literalNames,
                             std::vector<std::string> symbolicNames)
            : ruleNames(std::move(ruleNames))
            , literalNames(std::move(literalNames))
            , symbolicNames(std::move(symbolicNames))
            , vocabulary(this->literalNames, this->symbolicNames)
        {}

        AnceParserStaticData(AnceParserStaticData const&)            = delete;
        AnceParserStaticData(AnceParserStaticData&&)                 = delete;
        AnceParserStaticData& operator=(AnceParserStaticData const&) = delete;
        AnceParserStaticData& operator=(AnceParserStaticData&&)      = delete;

        std::vector<antlr4::dfa::DFA>       decisionToDFA;
        antlr4::atn::PredictionContextCache sharedContextCache;
        const std::vector<std::string>      ruleNames;
        const std::vector<std::string>      literalNames;
        const std::vector<std::string>      symbolicNames;
        const antlr4::dfa::Vocabulary       vocabulary;
        antlr4::atn::SerializedATNView      serializedATN;
        std::unique_ptr<antlr4::atn::ATN>   atn;
    };

    std::once_flag        anceParserOnceFlag;
    AnceParserStaticData* anceParserStaticData = nullptr;

    void anceParserInitialize()
    {
        assert(anceParserStaticData == nullptr);
        auto staticData =
            std::make_unique<AnceParserStaticData>(std::vector<std::string> {"file",
                                                                             "variableDeclaration",
                                                                             "function",
                                                                             "parameters",
                                                                             "parameter",
                                                                             "typeDefinition",
                                                                             "defineAlias",
                                                                             "structDefinition",
                                                                             "member",
                                                                             "accessModifier",
                                                                             "code",
                                                                             "block",
                                                                             "statement",
                                                                             "expressionStatement",
                                                                             "localVariableDefinition",
                                                                             "localReferenceDefinition",
                                                                             "dropStatement",
                                                                             "assignment",
                                                                             "assigner",
                                                                             "deleteStatement",
                                                                             "returnStatement",
                                                                             "assertStatement",
                                                                             "ifStatement",
                                                                             "whileStatement",
                                                                             "matchStatement",
                                                                             "matchCase",
                                                                             "expression",
                                                                             "unaryOperator",
                                                                             "binaryOperatorMultiplicative",
                                                                             "binaryOperatorAdditive",
                                                                             "binaryOperatorBitwise",
                                                                             "binaryOperatorShift",
                                                                             "binaryOperatorRelational",
                                                                             "binaryOperatorEquality",
                                                                             "independentExpression",
                                                                             "functionCall",
                                                                             "arguments",
                                                                             "variableAccess",
                                                                             "allocation",
                                                                             "allocator",
                                                                             "addressof",
                                                                             "bindRef",
                                                                             "sizeofType",
                                                                             "sizeofExpression",
                                                                             "matchExpression",
                                                                             "matchExpressionCase",
                                                                             "literalExpression",
                                                                             "stringLiteral",
                                                                             "charLiteral",
                                                                             "integerLiteral",
                                                                             "normalInteger",
                                                                             "specialInteger",
                                                                             "floatingPointLiteral",
                                                                             "booleanLiteral",
                                                                             "nullLiteral",
                                                                             "sizeLiteral",
                                                                             "diffLiteral",
                                                                             "uiptrLiteral",
                                                                             "type",
                                                                             "integerType",
                                                                             "arrayType",
                                                                             "vectorType",
                                                                             "keywordType",
                                                                             "floatingPointType",
                                                                             "targetDependentType",
                                                                             "booleanType",
                                                                             "charType",
                                                                             "nullPointerType",
                                                                             "voidType",
                                                                             "customType"},
                                                   std::vector<std::string> {"",
                                                                             "':'",
                                                                             "'('",
                                                                             "')'",
                                                                             "'{'",
                                                                             "'}'",
                                                                             "'extern'",
                                                                             "','",
                                                                             "'define'",
                                                                             "'alias'",
                                                                             "'struct'",
                                                                             "'public'",
                                                                             "'private'",
                                                                             "'let'",
                                                                             "'drop'",
                                                                             "'<:'",
                                                                             "'<-'",
                                                                             "':='",
                                                                             "'delete'",
                                                                             "'return'",
                                                                             "'assert'",
                                                                             "'if'",
                                                                             "'then'",
                                                                             "'else'",
                                                                             "'while'",
                                                                             "'do'",
                                                                             "'match'",
                                                                             "'with'",
                                                                             "'|'",
                                                                             "'=>'",
                                                                             "'default'",
                                                                             "'.'",
                                                                             "'['",
                                                                             "']'",
                                                                             "'and'",
                                                                             "'or'",
                                                                             "'<'",
                                                                             "'>'",
                                                                             "'<not>'",
                                                                             "'-'",
                                                                             "'*'",
                                                                             "'/'",
                                                                             "'%'",
                                                                             "'+'",
                                                                             "'<and>'",
                                                                             "'<or>'",
                                                                             "'<xor>'",
                                                                             "'<sl>'",
                                                                             "'<sr>'",
                                                                             "'<='",
                                                                             "'>='",
                                                                             "'=='",
                                                                             "'/='",
                                                                             "'new'",
                                                                             "'dynamic'",
                                                                             "'automatic'",
                                                                             "'addressof'",
                                                                             "'ref'",
                                                                             "'to'",
                                                                             "'sizeof'",
                                                                             "'true'",
                                                                             "'false'",
                                                                             "'null'",
                                                                             "'size'",
                                                                             "'diff'",
                                                                             "'uiptr'",
                                                                             "'&'",
                                                                             "'half'",
                                                                             "'single'",
                                                                             "'double'",
                                                                             "'quad'",
                                                                             "'ptr'",
                                                                             "'bool'",
                                                                             "'char'",
                                                                             "'nullptr'",
                                                                             "'void'",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "'[]'",
                                                                             "'const'",
                                                                             "'not'",
                                                                             "",
                                                                             "';'"},
                                                   std::vector<std::string> {"",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "",
                                                                             "NATIVE_INTEGER_TYPE",
                                                                             "SIGNED_INTEGER",
                                                                             "HEX_INTEGER",
                                                                             "BIN_INTEGER",
                                                                             "OCT_INTEGER",
                                                                             "HALF",
                                                                             "SINGLE",
                                                                             "DOUBLE",
                                                                             "QUAD",
                                                                             "DECIMAL",
                                                                             "STRING",
                                                                             "CHAR",
                                                                             "INTEGER",
                                                                             "BUFFER",
                                                                             "CONST",
                                                                             "NOT",
                                                                             "IDENTIFIER",
                                                                             "SEMICOLON",
                                                                             "WHITESPACE",
                                                                             "BLOCK_COMMENT",
                                                                             "LINE_COMMENT"});
        static const int32_t serializedATNSegment[] = {
            4,   1,   96,  715, 2,   0,   7,   0,   2,   1,   7,   1,   2,   2,   7,   2,   2,   3,   7,   3,   2,
            4,   7,   4,   2,   5,   7,   5,   2,   6,   7,   6,   2,   7,   7,   7,   2,   8,   7,   8,   2,   9,
            7,   9,   2,   10,  7,   10,  2,   11,  7,   11,  2,   12,  7,   12,  2,   13,  7,   13,  2,   14,  7,
            14,  2,   15,  7,   15,  2,   16,  7,   16,  2,   17,  7,   17,  2,   18,  7,   18,  2,   19,  7,   19,
            2,   20,  7,   20,  2,   21,  7,   21,  2,   22,  7,   22,  2,   23,  7,   23,  2,   24,  7,   24,  2,
            25,  7,   25,  2,   26,  7,   26,  2,   27,  7,   27,  2,   28,  7,   28,  2,   29,  7,   29,  2,   30,
            7,   30,  2,   31,  7,   31,  2,   32,  7,   32,  2,   33,  7,   33,  2,   34,  7,   34,  2,   35,  7,
            35,  2,   36,  7,   36,  2,   37,  7,   37,  2,   38,  7,   38,  2,   39,  7,   39,  2,   40,  7,   40,
            2,   41,  7,   41,  2,   42,  7,   42,  2,   43,  7,   43,  2,   44,  7,   44,  2,   45,  7,   45,  2,
            46,  7,   46,  2,   47,  7,   47,  2,   48,  7,   48,  2,   49,  7,   49,  2,   50,  7,   50,  2,   51,
            7,   51,  2,   52,  7,   52,  2,   53,  7,   53,  2,   54,  7,   54,  2,   55,  7,   55,  2,   56,  7,
            56,  2,   57,  7,   57,  2,   58,  7,   58,  2,   59,  7,   59,  2,   60,  7,   60,  2,   61,  7,   61,
            2,   62,  7,   62,  2,   63,  7,   63,  2,   64,  7,   64,  2,   65,  7,   65,  2,   66,  7,   66,  2,
            67,  7,   67,  2,   68,  7,   68,  2,   69,  7,   69,  1,   0,   1,   0,   1,   0,   5,   0,   144, 8,
            0,   10,  0,   12,  0,   147, 9,   0,   1,   0,   1,   0,   1,   1,   1,   1,   3,   1,   153, 8,   1,
            1,   1,   1,   1,   1,   1,   3,   1,   158, 8,   1,   1,   1,   1,   1,   1,   1,   3,   1,   163, 8,
            1,   1,   1,   1,   1,   1,   2,   1,   2,   1,   2,   1,   2,   1,   2,   1,   2,   1,   2,   3,   2,
            174, 8,   2,   1,   2,   1,   2,   5,   2,   178, 8,   2,   10,  2,   12,  2,   181, 9,   2,   1,   2,
            1,   2,   1,   2,   1,   2,   1,   2,   1,   2,   1,   2,   1,   2,   1,   2,   3,   2,   192, 8,   2,
            1,   2,   1,   2,   3,   2,   196, 8,   2,   1,   3,   1,   3,   1,   3,   5,   3,   201, 8,   3,   10,
            3,   12,  3,   204, 9,   3,   3,   3,   206, 8,   3,   1,   4,   1,   4,   1,   4,   1,   4,   1,   5,
            1,   5,   3,   5,   214, 8,   5,   1,   6,   1,   6,   1,   6,   1,   6,   1,   6,   1,   6,   1,   6,
            1,   7,   1,   7,   1,   7,   1,   7,   1,   7,   5,   7,   228, 8,   7,   10,  7,   12,  7,   231, 9,
            7,   1,   7,   1,   7,   1,   8,   1,   8,   1,   8,   1,   8,   1,   8,   1,   8,   1,   8,   3,   8,
            242, 8,   8,   1,   8,   1,   8,   1,   9,   1,   9,   3,   9,   248, 8,   9,   1,   10,  1,   10,  3,
            10,  252, 8,   10,  1,   11,  1,   11,  5,   11,  256, 8,   11,  10,  11,  12,  11,  259, 9,   11,  1,
            11,  1,   11,  1,   12,  1,   12,  1,   12,  1,   12,  1,   12,  1,   12,  1,   12,  1,   12,  1,   12,
            1,   12,  1,   12,  3,   12,  274, 8,   12,  1,   13,  1,   13,  1,   13,  1,   14,  1,   14,  1,   14,
            1,   14,  3,   14,  283, 8,   14,  1,   14,  1,   14,  1,   14,  3,   14,  288, 8,   14,  1,   14,  1,
            14,  1,   15,  1,   15,  1,   15,  1,   15,  1,   15,  1,   15,  1,   15,  1,   16,  1,   16,  1,   16,
            1,   16,  1,   17,  1,   17,  1,   17,  1,   17,  1,   17,  1,   18,  1,   18,  1,   18,  3,   18,  311,
            8,   18,  1,   19,  1,   19,  3,   19,  315, 8,   19,  1,   19,  1,   19,  1,   19,  1,   20,  1,   20,
            3,   20,  322, 8,   20,  1,   20,  1,   20,  1,   21,  1,   21,  1,   21,  1,   21,  1,   22,  1,   22,
            1,   22,  1,   22,  1,   22,  1,   22,  3,   22,  336, 8,   22,  1,   23,  1,   23,  1,   23,  1,   23,
            1,   23,  1,   24,  1,   24,  1,   24,  1,   24,  1,   24,  5,   24,  348, 8,   24,  10,  24,  12,  24,
            351, 9,   24,  1,   24,  1,   24,  1,   25,  1,   25,  1,   25,  5,   25,  358, 8,   25,  10,  25,  12,
            25,  361, 9,   25,  1,   25,  1,   25,  1,   25,  1,   25,  1,   25,  1,   25,  3,   25,  369, 8,   25,
            1,   26,  1,   26,  1,   26,  1,   26,  1,   26,  1,   26,  1,   26,  1,   26,  1,   26,  1,   26,  1,
            26,  1,   26,  1,   26,  1,   26,  1,   26,  1,   26,  1,   26,  1,   26,  1,   26,  1,   26,  1,   26,
            1,   26,  1,   26,  1,   26,  1,   26,  1,   26,  1,   26,  1,   26,  3,   26,  399, 8,   26,  1,   26,
            1,   26,  1,   26,  5,   26,  404, 8,   26,  10,  26,  12,  26,  407, 9,   26,  1,   26,  1,   26,  1,
            26,  1,   26,  1,   26,  1,   26,  3,   26,  415, 8,   26,  1,   26,  1,   26,  1,   26,  5,   26,  420,
            8,   26,  10,  26,  12,  26,  423, 9,   26,  1,   26,  1,   26,  3,   26,  427, 8,   26,  1,   26,  1,
            26,  1,   26,  1,   26,  1,   26,  1,   26,  1,   26,  1,   26,  1,   26,  1,   26,  1,   26,  1,   26,
            1,   26,  1,   26,  1,   26,  1,   26,  1,   26,  1,   26,  1,   26,  1,   26,  1,   26,  1,   26,  1,
            26,  1,   26,  1,   26,  1,   26,  3,   26,  455, 8,   26,  1,   26,  1,   26,  1,   26,  1,   26,  3,
            26,  461, 8,   26,  1,   26,  1,   26,  1,   26,  1,   26,  1,   26,  1,   26,  1,   26,  1,   26,  1,
            26,  1,   26,  1,   26,  5,   26,  474, 8,   26,  10,  26,  12,  26,  477, 9,   26,  1,   27,  1,   27,
            1,   27,  3,   27,  482, 8,   27,  1,   28,  1,   28,  1,   28,  3,   28,  487, 8,   28,  1,   29,  1,
            29,  3,   29,  491, 8,   29,  1,   30,  1,   30,  1,   30,  3,   30,  496, 8,   30,  1,   31,  1,   31,
            3,   31,  500, 8,   31,  1,   32,  1,   32,  1,   32,  1,   32,  3,   32,  506, 8,   32,  1,   33,  1,
            33,  3,   33,  510, 8,   33,  1,   34,  1,   34,  1,   35,  1,   35,  1,   35,  1,   35,  1,   35,  1,
            35,  1,   35,  1,   35,  1,   35,  1,   35,  3,   35,  524, 8,   35,  1,   36,  1,   36,  1,   36,  5,
            36,  529, 8,   36,  10,  36,  12,  36,  532, 9,   36,  3,   36,  534, 8,   36,  1,   37,  1,   37,  1,
            38,  1,   38,  1,   38,  1,   38,  1,   38,  3,   38,  543, 8,   38,  1,   38,  1,   38,  1,   38,  1,
            39,  1,   39,  3,   39,  550, 8,   39,  1,   40,  1,   40,  1,   40,  1,   41,  1,   41,  1,   41,  1,
            41,  1,   41,  3,   41,  560, 8,   41,  1,   42,  1,   42,  1,   42,  1,   43,  1,   43,  1,   43,  1,
            43,  1,   43,  1,   44,  1,   44,  1,   44,  1,   44,  1,   44,  1,   44,  1,   44,  5,   44,  577, 8,
            44,  10,  44,  12,  44,  580, 9,   44,  3,   44,  582, 8,   44,  1,   44,  1,   44,  1,   45,  1,   45,
            1,   45,  5,   45,  589, 8,   45,  10,  45,  12,  45,  592, 9,   45,  1,   45,  1,   45,  1,   45,  1,
            45,  1,   45,  1,   45,  3,   45,  600, 8,   45,  1,   46,  1,   46,  1,   46,  1,   46,  1,   46,  1,
            46,  1,   46,  1,   46,  1,   46,  3,   46,  611, 8,   46,  1,   47,  3,   47,  614, 8,   47,  1,   47,
            1,   47,  1,   48,  3,   48,  619, 8,   48,  1,   48,  1,   48,  1,   49,  1,   49,  3,   49,  625, 8,
            49,  1,   50,  1,   50,  3,   50,  629, 8,   50,  1,   50,  1,   50,  3,   50,  633, 8,   50,  1,   51,
            1,   51,  1,   51,  1,   51,  1,   51,  1,   51,  1,   51,  1,   51,  1,   51,  3,   51,  644, 8,   51,
            1,   52,  1,   52,  1,   53,  1,   53,  3,   53,  650, 8,   53,  1,   54,  1,   54,  1,   55,  1,   55,
            1,   55,  1,   55,  1,   56,  1,   56,  1,   56,  1,   56,  1,   57,  1,   57,  1,   57,  1,   57,  1,
            58,  1,   58,  1,   58,  1,   58,  1,   58,  1,   58,  1,   58,  1,   58,  1,   58,  1,   58,  1,   58,
            3,   58,  677, 8,   58,  1,   59,  1,   59,  1,   60,  1,   60,  1,   60,  1,   60,  1,   60,  1,   60,
            1,   61,  1,   61,  1,   61,  1,   61,  1,   61,  1,   61,  1,   62,  1,   62,  1,   62,  1,   62,  1,
            62,  1,   62,  3,   62,  699, 8,   62,  1,   63,  1,   63,  1,   64,  1,   64,  1,   65,  1,   65,  1,
            66,  1,   66,  1,   67,  1,   67,  1,   68,  1,   68,  1,   69,  1,   69,  1,   69,  0,   1,   52,  70,
            0,   2,   4,   6,   8,   10,  12,  14,  16,  18,  20,  22,  24,  26,  28,  30,  32,  34,  36,  38,  40,
            42,  44,  46,  48,  50,  52,  54,  56,  58,  60,  62,  64,  66,  68,  70,  72,  74,  76,  78,  80,  82,
            84,  86,  88,  90,  92,  94,  96,  98,  100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124,
            126, 128, 130, 132, 134, 136, 138, 0,   4,   2,   0,   88,  88,  92,  92,  1,   0,   81,  84,  1,   0,
            67,  70,  2,   0,   63,  65,  71,  71,  762, 0,   145, 1,   0,   0,   0,   2,   150, 1,   0,   0,   0,
            4,   195, 1,   0,   0,   0,   6,   205, 1,   0,   0,   0,   8,   207, 1,   0,   0,   0,   10,  213, 1,
            0,   0,   0,   12,  215, 1,   0,   0,   0,   14,  222, 1,   0,   0,   0,   16,  234, 1,   0,   0,   0,
            18,  247, 1,   0,   0,   0,   20,  251, 1,   0,   0,   0,   22,  253, 1,   0,   0,   0,   24,  273, 1,
            0,   0,   0,   26,  275, 1,   0,   0,   0,   28,  278, 1,   0,   0,   0,   30,  291, 1,   0,   0,   0,
            32,  298, 1,   0,   0,   0,   34,  302, 1,   0,   0,   0,   36,  310, 1,   0,   0,   0,   38,  312, 1,
            0,   0,   0,   40,  319, 1,   0,   0,   0,   42,  325, 1,   0,   0,   0,   44,  329, 1,   0,   0,   0,
            46,  337, 1,   0,   0,   0,   48,  342, 1,   0,   0,   0,   50,  368, 1,   0,   0,   0,   52,  426, 1,
            0,   0,   0,   54,  481, 1,   0,   0,   0,   56,  486, 1,   0,   0,   0,   58,  490, 1,   0,   0,   0,
            60,  495, 1,   0,   0,   0,   62,  499, 1,   0,   0,   0,   64,  505, 1,   0,   0,   0,   66,  509, 1,
            0,   0,   0,   68,  511, 1,   0,   0,   0,   70,  523, 1,   0,   0,   0,   72,  533, 1,   0,   0,   0,
            74,  535, 1,   0,   0,   0,   76,  537, 1,   0,   0,   0,   78,  549, 1,   0,   0,   0,   80,  551, 1,
            0,   0,   0,   82,  559, 1,   0,   0,   0,   84,  561, 1,   0,   0,   0,   86,  564, 1,   0,   0,   0,
            88,  569, 1,   0,   0,   0,   90,  599, 1,   0,   0,   0,   92,  610, 1,   0,   0,   0,   94,  613, 1,
            0,   0,   0,   96,  618, 1,   0,   0,   0,   98,  624, 1,   0,   0,   0,   100, 628, 1,   0,   0,   0,
            102, 643, 1,   0,   0,   0,   104, 645, 1,   0,   0,   0,   106, 649, 1,   0,   0,   0,   108, 651, 1,
            0,   0,   0,   110, 653, 1,   0,   0,   0,   112, 657, 1,   0,   0,   0,   114, 661, 1,   0,   0,   0,
            116, 676, 1,   0,   0,   0,   118, 678, 1,   0,   0,   0,   120, 680, 1,   0,   0,   0,   122, 686, 1,
            0,   0,   0,   124, 698, 1,   0,   0,   0,   126, 700, 1,   0,   0,   0,   128, 702, 1,   0,   0,   0,
            130, 704, 1,   0,   0,   0,   132, 706, 1,   0,   0,   0,   134, 708, 1,   0,   0,   0,   136, 710, 1,
            0,   0,   0,   138, 712, 1,   0,   0,   0,   140, 144, 3,   2,   1,   0,   141, 144, 3,   4,   2,   0,
            142, 144, 3,   10,  5,   0,   143, 140, 1,   0,   0,   0,   143, 141, 1,   0,   0,   0,   143, 142, 1,
            0,   0,   0,   144, 147, 1,   0,   0,   0,   145, 143, 1,   0,   0,   0,   145, 146, 1,   0,   0,   0,
            146, 148, 1,   0,   0,   0,   147, 145, 1,   0,   0,   0,   148, 149, 5,   0,   0,   1,   149, 1,   1,
            0,   0,   0,   150, 152, 3,   18,  9,   0,   151, 153, 5,   90,  0,   0,   152, 151, 1,   0,   0,   0,
            152, 153, 1,   0,   0,   0,   153, 154, 1,   0,   0,   0,   154, 157, 5,   92,  0,   0,   155, 156, 5,
            1,   0,   0,   156, 158, 3,   116, 58,  0,   157, 155, 1,   0,   0,   0,   157, 158, 1,   0,   0,   0,
            158, 162, 1,   0,   0,   0,   159, 160, 3,   36,  18,  0,   160, 161, 3,   52,  26,  0,   161, 163, 1,
            0,   0,   0,   162, 159, 1,   0,   0,   0,   162, 163, 1,   0,   0,   0,   163, 164, 1,   0,   0,   0,
            164, 165, 5,   93,  0,   0,   165, 3,   1,   0,   0,   0,   166, 167, 3,   18,  9,   0,   167, 168, 5,
            92,  0,   0,   168, 169, 5,   2,   0,   0,   169, 170, 3,   6,   3,   0,   170, 173, 5,   3,   0,   0,
            171, 172, 5,   1,   0,   0,   172, 174, 3,   116, 58,  0,   173, 171, 1,   0,   0,   0,   173, 174, 1,
            0,   0,   0,   174, 175, 1,   0,   0,   0,   175, 179, 5,   4,   0,   0,   176, 178, 3,   20,  10,  0,
            177, 176, 1,   0,   0,   0,   178, 181, 1,   0,   0,   0,   179, 177, 1,   0,   0,   0,   179, 180, 1,
            0,   0,   0,   180, 182, 1,   0,   0,   0,   181, 179, 1,   0,   0,   0,   182, 183, 5,   5,   0,   0,
            183, 196, 1,   0,   0,   0,   184, 185, 5,   6,   0,   0,   185, 186, 5,   92,  0,   0,   186, 187, 5,
            2,   0,   0,   187, 188, 3,   6,   3,   0,   188, 191, 5,   3,   0,   0,   189, 190, 5,   1,   0,   0,
            190, 192, 3,   116, 58,  0,   191, 189, 1,   0,   0,   0,   191, 192, 1,   0,   0,   0,   192, 193, 1,
            0,   0,   0,   193, 194, 5,   93,  0,   0,   194, 196, 1,   0,   0,   0,   195, 166, 1,   0,   0,   0,
            195, 184, 1,   0,   0,   0,   196, 5,   1,   0,   0,   0,   197, 202, 3,   8,   4,   0,   198, 199, 5,
            7,   0,   0,   199, 201, 3,   8,   4,   0,   200, 198, 1,   0,   0,   0,   201, 204, 1,   0,   0,   0,
            202, 200, 1,   0,   0,   0,   202, 203, 1,   0,   0,   0,   203, 206, 1,   0,   0,   0,   204, 202, 1,
            0,   0,   0,   205, 197, 1,   0,   0,   0,   205, 206, 1,   0,   0,   0,   206, 7,   1,   0,   0,   0,
            207, 208, 5,   92,  0,   0,   208, 209, 5,   1,   0,   0,   209, 210, 3,   116, 58,  0,   210, 9,   1,
            0,   0,   0,   211, 214, 3,   12,  6,   0,   212, 214, 3,   14,  7,   0,   213, 211, 1,   0,   0,   0,
            213, 212, 1,   0,   0,   0,   214, 11,  1,   0,   0,   0,   215, 216, 3,   18,  9,   0,   216, 217, 5,
            8,   0,   0,   217, 218, 5,   92,  0,   0,   218, 219, 5,   9,   0,   0,   219, 220, 3,   116, 58,  0,
            220, 221, 5,   93,  0,   0,   221, 13,  1,   0,   0,   0,   222, 223, 3,   18,  9,   0,   223, 224, 5,
            10,  0,   0,   224, 225, 5,   92,  0,   0,   225, 229, 5,   4,   0,   0,   226, 228, 3,   16,  8,   0,
            227, 226, 1,   0,   0,   0,   228, 231, 1,   0,   0,   0,   229, 227, 1,   0,   0,   0,   229, 230, 1,
            0,   0,   0,   230, 232, 1,   0,   0,   0,   231, 229, 1,   0,   0,   0,   232, 233, 5,   5,   0,   0,
            233, 15,  1,   0,   0,   0,   234, 235, 3,   18,  9,   0,   235, 236, 5,   92,  0,   0,   236, 237, 5,
            1,   0,   0,   237, 241, 3,   116, 58,  0,   238, 239, 3,   36,  18,  0,   239, 240, 3,   92,  46,  0,
            240, 242, 1,   0,   0,   0,   241, 238, 1,   0,   0,   0,   241, 242, 1,   0,   0,   0,   242, 243, 1,
            0,   0,   0,   243, 244, 5,   93,  0,   0,   244, 17,  1,   0,   0,   0,   245, 248, 5,   11,  0,   0,
            246, 248, 5,   12,  0,   0,   247, 245, 1,   0,   0,   0,   247, 246, 1,   0,   0,   0,   248, 19,  1,
            0,   0,   0,   249, 252, 3,   24,  12,  0,   250, 252, 3,   22,  11,  0,   251, 249, 1,   0,   0,   0,
            251, 250, 1,   0,   0,   0,   252, 21,  1,   0,   0,   0,   253, 257, 5,   4,   0,   0,   254, 256, 3,
            20,  10,  0,   255, 254, 1,   0,   0,   0,   256, 259, 1,   0,   0,   0,   257, 255, 1,   0,   0,   0,
            257, 258, 1,   0,   0,   0,   258, 260, 1,   0,   0,   0,   259, 257, 1,   0,   0,   0,   260, 261, 5,
            5,   0,   0,   261, 23,  1,   0,   0,   0,   262, 274, 3,   26,  13,  0,   263, 274, 3,   28,  14,  0,
            264, 274, 3,   30,  15,  0,   265, 274, 3,   32,  16,  0,   266, 274, 3,   34,  17,  0,   267, 274, 3,
            38,  19,  0,   268, 274, 3,   40,  20,  0,   269, 274, 3,   42,  21,  0,   270, 274, 3,   44,  22,  0,
            271, 274, 3,   46,  23,  0,   272, 274, 3,   48,  24,  0,   273, 262, 1,   0,   0,   0,   273, 263, 1,
            0,   0,   0,   273, 264, 1,   0,   0,   0,   273, 265, 1,   0,   0,   0,   273, 266, 1,   0,   0,   0,
            273, 267, 1,   0,   0,   0,   273, 268, 1,   0,   0,   0,   273, 269, 1,   0,   0,   0,   273, 270, 1,
            0,   0,   0,   273, 271, 1,   0,   0,   0,   273, 272, 1,   0,   0,   0,   274, 25,  1,   0,   0,   0,
            275, 276, 3,   68,  34,  0,   276, 277, 5,   93,  0,   0,   277, 27,  1,   0,   0,   0,   278, 279, 5,
            13,  0,   0,   279, 282, 5,   92,  0,   0,   280, 281, 5,   1,   0,   0,   281, 283, 3,   116, 58,  0,
            282, 280, 1,   0,   0,   0,   282, 283, 1,   0,   0,   0,   283, 287, 1,   0,   0,   0,   284, 285, 3,
            36,  18,  0,   285, 286, 3,   52,  26,  0,   286, 288, 1,   0,   0,   0,   287, 284, 1,   0,   0,   0,
            287, 288, 1,   0,   0,   0,   288, 289, 1,   0,   0,   0,   289, 290, 5,   93,  0,   0,   290, 29,  1,
            0,   0,   0,   291, 292, 5,   13,  0,   0,   292, 293, 5,   92,  0,   0,   293, 294, 5,   1,   0,   0,
            294, 295, 3,   116, 58,  0,   295, 296, 3,   82,  41,  0,   296, 297, 5,   93,  0,   0,   297, 31,  1,
            0,   0,   0,   298, 299, 5,   14,  0,   0,   299, 300, 5,   92,  0,   0,   300, 301, 5,   93,  0,   0,
            301, 33,  1,   0,   0,   0,   302, 303, 3,   52,  26,  0,   303, 304, 3,   36,  18,  0,   304, 305, 3,
            52,  26,  0,   305, 306, 5,   93,  0,   0,   306, 35,  1,   0,   0,   0,   307, 311, 5,   15,  0,   0,
            308, 311, 5,   16,  0,   0,   309, 311, 5,   17,  0,   0,   310, 307, 1,   0,   0,   0,   310, 308, 1,
            0,   0,   0,   310, 309, 1,   0,   0,   0,   311, 37,  1,   0,   0,   0,   312, 314, 5,   18,  0,   0,
            313, 315, 5,   89,  0,   0,   314, 313, 1,   0,   0,   0,   314, 315, 1,   0,   0,   0,   315, 316, 1,
            0,   0,   0,   316, 317, 3,   52,  26,  0,   317, 318, 5,   93,  0,   0,   318, 39,  1,   0,   0,   0,
            319, 321, 5,   19,  0,   0,   320, 322, 3,   52,  26,  0,   321, 320, 1,   0,   0,   0,   321, 322, 1,
            0,   0,   0,   322, 323, 1,   0,   0,   0,   323, 324, 5,   93,  0,   0,   324, 41,  1,   0,   0,   0,
            325, 326, 5,   20,  0,   0,   326, 327, 3,   52,  26,  0,   327, 328, 5,   93,  0,   0,   328, 43,  1,
            0,   0,   0,   329, 330, 5,   21,  0,   0,   330, 331, 3,   52,  26,  0,   331, 332, 5,   22,  0,   0,
            332, 335, 3,   20,  10,  0,   333, 334, 5,   23,  0,   0,   334, 336, 3,   20,  10,  0,   335, 333, 1,
            0,   0,   0,   335, 336, 1,   0,   0,   0,   336, 45,  1,   0,   0,   0,   337, 338, 5,   24,  0,   0,
            338, 339, 3,   52,  26,  0,   339, 340, 5,   25,  0,   0,   340, 341, 3,   20,  10,  0,   341, 47,  1,
            0,   0,   0,   342, 343, 5,   26,  0,   0,   343, 344, 3,   52,  26,  0,   344, 345, 5,   27,  0,   0,
            345, 349, 5,   4,   0,   0,   346, 348, 3,   50,  25,  0,   347, 346, 1,   0,   0,   0,   348, 351, 1,
            0,   0,   0,   349, 347, 1,   0,   0,   0,   349, 350, 1,   0,   0,   0,   350, 352, 1,   0,   0,   0,
            351, 349, 1,   0,   0,   0,   352, 353, 5,   5,   0,   0,   353, 49,  1,   0,   0,   0,   354, 359, 3,
            92,  46,  0,   355, 356, 5,   28,  0,   0,   356, 358, 3,   92,  46,  0,   357, 355, 1,   0,   0,   0,
            358, 361, 1,   0,   0,   0,   359, 357, 1,   0,   0,   0,   359, 360, 1,   0,   0,   0,   360, 362, 1,
            0,   0,   0,   361, 359, 1,   0,   0,   0,   362, 363, 5,   29,  0,   0,   363, 364, 3,   20,  10,  0,
            364, 369, 1,   0,   0,   0,   365, 366, 5,   30,  0,   0,   366, 367, 5,   29,  0,   0,   367, 369, 3,
            20,  10,  0,   368, 354, 1,   0,   0,   0,   368, 365, 1,   0,   0,   0,   369, 51,  1,   0,   0,   0,
            370, 371, 6,   26,  -1,  0,   371, 427, 3,   74,  37,  0,   372, 427, 3,   76,  38,  0,   373, 427, 3,
            92,  46,  0,   374, 427, 3,   80,  40,  0,   375, 427, 3,   82,  41,  0,   376, 427, 3,   84,  42,  0,
            377, 427, 3,   86,  43,  0,   378, 427, 3,   68,  34,  0,   379, 380, 5,   2,   0,   0,   380, 381, 3,
            52,  26,  0,   381, 382, 5,   3,   0,   0,   382, 427, 1,   0,   0,   0,   383, 384, 3,   54,  27,  0,
            384, 385, 3,   52,  26,  13,  385, 427, 1,   0,   0,   0,   386, 387, 5,   21,  0,   0,   387, 388, 3,
            52,  26,  0,   388, 389, 5,   22,  0,   0,   389, 390, 3,   52,  26,  0,   390, 391, 5,   23,  0,   0,
            391, 392, 3,   52,  26,  4,   392, 427, 1,   0,   0,   0,   393, 427, 3,   88,  44,  0,   394, 398, 5,
            36,  0,   0,   395, 396, 3,   116, 58,  0,   396, 397, 5,   28,  0,   0,   397, 399, 1,   0,   0,   0,
            398, 395, 1,   0,   0,   0,   398, 399, 1,   0,   0,   0,   399, 400, 1,   0,   0,   0,   400, 405, 3,
            52,  26,  0,   401, 402, 5,   7,   0,   0,   402, 404, 3,   52,  26,  0,   403, 401, 1,   0,   0,   0,
            404, 407, 1,   0,   0,   0,   405, 403, 1,   0,   0,   0,   405, 406, 1,   0,   0,   0,   406, 408, 1,
            0,   0,   0,   407, 405, 1,   0,   0,   0,   408, 409, 5,   37,  0,   0,   409, 427, 1,   0,   0,   0,
            410, 414, 5,   32,  0,   0,   411, 412, 3,   116, 58,  0,   412, 413, 5,   28,  0,   0,   413, 415, 1,
            0,   0,   0,   414, 411, 1,   0,   0,   0,   414, 415, 1,   0,   0,   0,   415, 416, 1,   0,   0,   0,
            416, 421, 3,   52,  26,  0,   417, 418, 5,   7,   0,   0,   418, 420, 3,   52,  26,  0,   419, 417, 1,
            0,   0,   0,   420, 423, 1,   0,   0,   0,   421, 419, 1,   0,   0,   0,   421, 422, 1,   0,   0,   0,
            422, 424, 1,   0,   0,   0,   423, 421, 1,   0,   0,   0,   424, 425, 5,   33,  0,   0,   425, 427, 1,
            0,   0,   0,   426, 370, 1,   0,   0,   0,   426, 372, 1,   0,   0,   0,   426, 373, 1,   0,   0,   0,
            426, 374, 1,   0,   0,   0,   426, 375, 1,   0,   0,   0,   426, 376, 1,   0,   0,   0,   426, 377, 1,
            0,   0,   0,   426, 378, 1,   0,   0,   0,   426, 379, 1,   0,   0,   0,   426, 383, 1,   0,   0,   0,
            426, 386, 1,   0,   0,   0,   426, 393, 1,   0,   0,   0,   426, 394, 1,   0,   0,   0,   426, 410, 1,
            0,   0,   0,   427, 475, 1,   0,   0,   0,   428, 429, 10,  12,  0,   0,   429, 430, 3,   56,  28,  0,
            430, 431, 3,   52,  26,  13,  431, 474, 1,   0,   0,   0,   432, 433, 10,  11,  0,   0,   433, 434, 3,
            58,  29,  0,   434, 435, 3,   52,  26,  12,  435, 474, 1,   0,   0,   0,   436, 437, 10,  10,  0,   0,
            437, 438, 3,   60,  30,  0,   438, 439, 3,   52,  26,  11,  439, 474, 1,   0,   0,   0,   440, 441, 10,
            9,   0,   0,   441, 442, 3,   62,  31,  0,   442, 443, 3,   52,  26,  10,  443, 474, 1,   0,   0,   0,
            444, 445, 10,  8,   0,   0,   445, 446, 3,   64,  32,  0,   446, 447, 3,   52,  26,  9,   447, 474, 1,
            0,   0,   0,   448, 449, 10,  7,   0,   0,   449, 450, 3,   66,  33,  0,   450, 451, 3,   52,  26,  8,
            451, 474, 1,   0,   0,   0,   452, 454, 10,  6,   0,   0,   453, 455, 5,   91,  0,   0,   454, 453, 1,
            0,   0,   0,   454, 455, 1,   0,   0,   0,   455, 456, 1,   0,   0,   0,   456, 457, 5,   34,  0,   0,
            457, 474, 3,   52,  26,  7,   458, 460, 10,  5,   0,   0,   459, 461, 5,   91,  0,   0,   460, 459, 1,
            0,   0,   0,   460, 461, 1,   0,   0,   0,   461, 462, 1,   0,   0,   0,   462, 463, 5,   35,  0,   0,
            463, 474, 3,   52,  26,  6,   464, 465, 10,  22,  0,   0,   465, 474, 5,   31,  0,   0,   466, 467, 10,
            21,  0,   0,   467, 468, 5,   32,  0,   0,   468, 469, 3,   52,  26,  0,   469, 470, 5,   33,  0,   0,
            470, 474, 1,   0,   0,   0,   471, 472, 10,  20,  0,   0,   472, 474, 5,   92,  0,   0,   473, 428, 1,
            0,   0,   0,   473, 432, 1,   0,   0,   0,   473, 436, 1,   0,   0,   0,   473, 440, 1,   0,   0,   0,
            473, 444, 1,   0,   0,   0,   473, 448, 1,   0,   0,   0,   473, 452, 1,   0,   0,   0,   473, 458, 1,
            0,   0,   0,   473, 464, 1,   0,   0,   0,   473, 466, 1,   0,   0,   0,   473, 471, 1,   0,   0,   0,
            474, 477, 1,   0,   0,   0,   475, 473, 1,   0,   0,   0,   475, 476, 1,   0,   0,   0,   476, 53,  1,
            0,   0,   0,   477, 475, 1,   0,   0,   0,   478, 482, 5,   91,  0,   0,   479, 482, 5,   38,  0,   0,
            480, 482, 5,   39,  0,   0,   481, 478, 1,   0,   0,   0,   481, 479, 1,   0,   0,   0,   481, 480, 1,
            0,   0,   0,   482, 55,  1,   0,   0,   0,   483, 487, 5,   40,  0,   0,   484, 487, 5,   41,  0,   0,
            485, 487, 5,   42,  0,   0,   486, 483, 1,   0,   0,   0,   486, 484, 1,   0,   0,   0,   486, 485, 1,
            0,   0,   0,   487, 57,  1,   0,   0,   0,   488, 491, 5,   43,  0,   0,   489, 491, 5,   39,  0,   0,
            490, 488, 1,   0,   0,   0,   490, 489, 1,   0,   0,   0,   491, 59,  1,   0,   0,   0,   492, 496, 5,
            44,  0,   0,   493, 496, 5,   45,  0,   0,   494, 496, 5,   46,  0,   0,   495, 492, 1,   0,   0,   0,
            495, 493, 1,   0,   0,   0,   495, 494, 1,   0,   0,   0,   496, 61,  1,   0,   0,   0,   497, 500, 5,
            47,  0,   0,   498, 500, 5,   48,  0,   0,   499, 497, 1,   0,   0,   0,   499, 498, 1,   0,   0,   0,
            500, 63,  1,   0,   0,   0,   501, 506, 5,   36,  0,   0,   502, 506, 5,   49,  0,   0,   503, 506, 5,
            37,  0,   0,   504, 506, 5,   50,  0,   0,   505, 501, 1,   0,   0,   0,   505, 502, 1,   0,   0,   0,
            505, 503, 1,   0,   0,   0,   505, 504, 1,   0,   0,   0,   506, 65,  1,   0,   0,   0,   507, 510, 5,
            51,  0,   0,   508, 510, 5,   52,  0,   0,   509, 507, 1,   0,   0,   0,   509, 508, 1,   0,   0,   0,
            510, 67,  1,   0,   0,   0,   511, 512, 3,   70,  35,  0,   512, 69,  1,   0,   0,   0,   513, 514, 5,
            92,  0,   0,   514, 515, 5,   2,   0,   0,   515, 516, 3,   72,  36,  0,   516, 517, 5,   3,   0,   0,
            517, 524, 1,   0,   0,   0,   518, 519, 3,   116, 58,  0,   519, 520, 5,   2,   0,   0,   520, 521, 3,
            72,  36,  0,   521, 522, 5,   3,   0,   0,   522, 524, 1,   0,   0,   0,   523, 513, 1,   0,   0,   0,
            523, 518, 1,   0,   0,   0,   524, 71,  1,   0,   0,   0,   525, 530, 3,   52,  26,  0,   526, 527, 5,
            7,   0,   0,   527, 529, 3,   52,  26,  0,   528, 526, 1,   0,   0,   0,   529, 532, 1,   0,   0,   0,
            530, 528, 1,   0,   0,   0,   530, 531, 1,   0,   0,   0,   531, 534, 1,   0,   0,   0,   532, 530, 1,
            0,   0,   0,   533, 525, 1,   0,   0,   0,   533, 534, 1,   0,   0,   0,   534, 73,  1,   0,   0,   0,
            535, 536, 5,   92,  0,   0,   536, 75,  1,   0,   0,   0,   537, 542, 5,   53,  0,   0,   538, 539, 5,
            32,  0,   0,   539, 540, 3,   52,  26,  0,   540, 541, 5,   33,  0,   0,   541, 543, 1,   0,   0,   0,
            542, 538, 1,   0,   0,   0,   542, 543, 1,   0,   0,   0,   543, 544, 1,   0,   0,   0,   544, 545, 3,
            78,  39,  0,   545, 546, 3,   116, 58,  0,   546, 77,  1,   0,   0,   0,   547, 550, 5,   54,  0,   0,
            548, 550, 5,   55,  0,   0,   549, 547, 1,   0,   0,   0,   549, 548, 1,   0,   0,   0,   550, 79,  1,
            0,   0,   0,   551, 552, 5,   56,  0,   0,   552, 553, 3,   52,  26,  0,   553, 81,  1,   0,   0,   0,
            554, 555, 5,   57,  0,   0,   555, 560, 3,   52,  26,  0,   556, 557, 5,   57,  0,   0,   557, 558, 5,
            58,  0,   0,   558, 560, 3,   52,  26,  0,   559, 554, 1,   0,   0,   0,   559, 556, 1,   0,   0,   0,
            560, 83,  1,   0,   0,   0,   561, 562, 5,   59,  0,   0,   562, 563, 3,   116, 58,  0,   563, 85,  1,
            0,   0,   0,   564, 565, 5,   59,  0,   0,   565, 566, 5,   2,   0,   0,   566, 567, 3,   52,  26,  0,
            567, 568, 5,   3,   0,   0,   568, 87,  1,   0,   0,   0,   569, 570, 5,   26,  0,   0,   570, 571, 3,
            52,  26,  0,   571, 572, 5,   27,  0,   0,   572, 581, 5,   4,   0,   0,   573, 578, 3,   90,  45,  0,
            574, 575, 5,   7,   0,   0,   575, 577, 3,   90,  45,  0,   576, 574, 1,   0,   0,   0,   577, 580, 1,
            0,   0,   0,   578, 576, 1,   0,   0,   0,   578, 579, 1,   0,   0,   0,   579, 582, 1,   0,   0,   0,
            580, 578, 1,   0,   0,   0,   581, 573, 1,   0,   0,   0,   581, 582, 1,   0,   0,   0,   582, 583, 1,
            0,   0,   0,   583, 584, 5,   5,   0,   0,   584, 89,  1,   0,   0,   0,   585, 590, 3,   92,  46,  0,
            586, 587, 5,   28,  0,   0,   587, 589, 3,   92,  46,  0,   588, 586, 1,   0,   0,   0,   589, 592, 1,
            0,   0,   0,   590, 588, 1,   0,   0,   0,   590, 591, 1,   0,   0,   0,   591, 593, 1,   0,   0,   0,
            592, 590, 1,   0,   0,   0,   593, 594, 5,   29,  0,   0,   594, 595, 3,   52,  26,  0,   595, 600, 1,
            0,   0,   0,   596, 597, 5,   30,  0,   0,   597, 598, 5,   29,  0,   0,   598, 600, 3,   52,  26,  0,
            599, 585, 1,   0,   0,   0,   599, 596, 1,   0,   0,   0,   600, 91,  1,   0,   0,   0,   601, 611, 3,
            94,  47,  0,   602, 611, 3,   96,  48,  0,   603, 611, 3,   98,  49,  0,   604, 611, 3,   104, 52,  0,
            605, 611, 3,   106, 53,  0,   606, 611, 3,   108, 54,  0,   607, 611, 3,   110, 55,  0,   608, 611, 3,
            112, 56,  0,   609, 611, 3,   114, 57,  0,   610, 601, 1,   0,   0,   0,   610, 602, 1,   0,   0,   0,
            610, 603, 1,   0,   0,   0,   610, 604, 1,   0,   0,   0,   610, 605, 1,   0,   0,   0,   610, 606, 1,
            0,   0,   0,   610, 607, 1,   0,   0,   0,   610, 608, 1,   0,   0,   0,   610, 609, 1,   0,   0,   0,
            611, 93,  1,   0,   0,   0,   612, 614, 7,   0,   0,   0,   613, 612, 1,   0,   0,   0,   613, 614, 1,
            0,   0,   0,   614, 615, 1,   0,   0,   0,   615, 616, 5,   86,  0,   0,   616, 95,  1,   0,   0,   0,
            617, 619, 7,   0,   0,   0,   618, 617, 1,   0,   0,   0,   618, 619, 1,   0,   0,   0,   619, 620, 1,
            0,   0,   0,   620, 621, 5,   87,  0,   0,   621, 97,  1,   0,   0,   0,   622, 625, 3,   100, 50,  0,
            623, 625, 3,   102, 51,  0,   624, 622, 1,   0,   0,   0,   624, 623, 1,   0,   0,   0,   625, 99,  1,
            0,   0,   0,   626, 629, 5,   88,  0,   0,   627, 629, 5,   77,  0,   0,   628, 626, 1,   0,   0,   0,
            628, 627, 1,   0,   0,   0,   629, 632, 1,   0,   0,   0,   630, 631, 5,   1,   0,   0,   631, 633, 5,
            88,  0,   0,   632, 630, 1,   0,   0,   0,   632, 633, 1,   0,   0,   0,   633, 101, 1,   0,   0,   0,
            634, 635, 5,   78,  0,   0,   635, 636, 5,   1,   0,   0,   636, 644, 5,   88,  0,   0,   637, 638, 5,
            79,  0,   0,   638, 639, 5,   1,   0,   0,   639, 644, 5,   88,  0,   0,   640, 641, 5,   80,  0,   0,
            641, 642, 5,   1,   0,   0,   642, 644, 5,   88,  0,   0,   643, 634, 1,   0,   0,   0,   643, 637, 1,
            0,   0,   0,   643, 640, 1,   0,   0,   0,   644, 103, 1,   0,   0,   0,   645, 646, 7,   1,   0,   0,
            646, 105, 1,   0,   0,   0,   647, 650, 5,   60,  0,   0,   648, 650, 5,   61,  0,   0,   649, 647, 1,
            0,   0,   0,   649, 648, 1,   0,   0,   0,   650, 107, 1,   0,   0,   0,   651, 652, 5,   62,  0,   0,
            652, 109, 1,   0,   0,   0,   653, 654, 5,   88,  0,   0,   654, 655, 5,   1,   0,   0,   655, 656, 5,
            63,  0,   0,   656, 111, 1,   0,   0,   0,   657, 658, 5,   77,  0,   0,   658, 659, 5,   1,   0,   0,
            659, 660, 5,   64,  0,   0,   660, 113, 1,   0,   0,   0,   661, 662, 5,   78,  0,   0,   662, 663, 5,
            1,   0,   0,   663, 664, 5,   65,  0,   0,   664, 115, 1,   0,   0,   0,   665, 677, 3,   118, 59,  0,
            666, 677, 3,   120, 60,  0,   667, 677, 3,   122, 61,  0,   668, 677, 3,   124, 62,  0,   669, 670, 5,
            40,  0,   0,   670, 677, 3,   116, 58,  0,   671, 672, 5,   89,  0,   0,   672, 677, 3,   116, 58,  0,
            673, 674, 5,   66,  0,   0,   674, 677, 3,   116, 58,  0,   675, 677, 3,   138, 69,  0,   676, 665, 1,
            0,   0,   0,   676, 666, 1,   0,   0,   0,   676, 667, 1,   0,   0,   0,   676, 668, 1,   0,   0,   0,
            676, 669, 1,   0,   0,   0,   676, 671, 1,   0,   0,   0,   676, 673, 1,   0,   0,   0,   676, 675, 1,
            0,   0,   0,   677, 117, 1,   0,   0,   0,   678, 679, 5,   76,  0,   0,   679, 119, 1,   0,   0,   0,
            680, 681, 5,   32,  0,   0,   681, 682, 3,   116, 58,  0,   682, 683, 5,   93,  0,   0,   683, 684, 5,
            88,  0,   0,   684, 685, 5,   33,  0,   0,   685, 121, 1,   0,   0,   0,   686, 687, 5,   36,  0,   0,
            687, 688, 3,   116, 58,  0,   688, 689, 5,   93,  0,   0,   689, 690, 5,   88,  0,   0,   690, 691, 5,
            37,  0,   0,   691, 123, 1,   0,   0,   0,   692, 699, 3,   126, 63,  0,   693, 699, 3,   128, 64,  0,
            694, 699, 3,   130, 65,  0,   695, 699, 3,   132, 66,  0,   696, 699, 3,   134, 67,  0,   697, 699, 3,
            136, 68,  0,   698, 692, 1,   0,   0,   0,   698, 693, 1,   0,   0,   0,   698, 694, 1,   0,   0,   0,
            698, 695, 1,   0,   0,   0,   698, 696, 1,   0,   0,   0,   698, 697, 1,   0,   0,   0,   699, 125, 1,
            0,   0,   0,   700, 701, 7,   2,   0,   0,   701, 127, 1,   0,   0,   0,   702, 703, 7,   3,   0,   0,
            703, 129, 1,   0,   0,   0,   704, 705, 5,   72,  0,   0,   705, 131, 1,   0,   0,   0,   706, 707, 5,
            73,  0,   0,   707, 133, 1,   0,   0,   0,   708, 709, 5,   74,  0,   0,   709, 135, 1,   0,   0,   0,
            710, 711, 5,   75,  0,   0,   711, 137, 1,   0,   0,   0,   712, 713, 5,   92,  0,   0,   713, 139, 1,
            0,   0,   0,   63,  143, 145, 152, 157, 162, 173, 179, 191, 195, 202, 205, 213, 229, 241, 247, 251, 257,
            273, 282, 287, 310, 314, 321, 335, 349, 359, 368, 398, 405, 414, 421, 426, 454, 460, 473, 475, 481, 486,
            490, 495, 499, 505, 509, 523, 530, 533, 542, 549, 559, 578, 581, 590, 599, 610, 613, 618, 624, 628, 632,
            643, 649, 676, 698};
        staticData->serializedATN =
            antlr4::atn::SerializedATNView(serializedATNSegment,
                                           sizeof(serializedATNSegment) / sizeof(serializedATNSegment[0]));

        antlr4::atn::ATNDeserializer deserializer;
        staticData->atn = deserializer.deserialize(staticData->serializedATN);

        const size_t count = staticData->atn->getNumberOfDecisions();
        staticData->decisionToDFA.reserve(count);
        for (size_t i = 0; i < count; i++)
        {
            staticData->decisionToDFA.emplace_back(staticData->atn->getDecisionState(i), i);
        }
        anceParserStaticData = staticData.release();
    }

}

anceParser::anceParser(TokenStream* input) : anceParser(input, antlr4::atn::ParserATNSimulatorOptions()) {}

anceParser::anceParser(TokenStream* input, antlr4::atn::ParserATNSimulatorOptions const& options) : Parser(input)
{
    anceParser::initialize();
    _interpreter = new atn::ParserATNSimulator(this,
                                               *anceParserStaticData->atn,
                                               anceParserStaticData->decisionToDFA,
                                               anceParserStaticData->sharedContextCache,
                                               options);
}

anceParser::~anceParser()
{
    delete _interpreter;
}

atn::ATN& anceParser::getATN() const {
  return *anceParserStaticData->atn;
}

std::string anceParser::getGrammarFileName() const
{
    return "ance.g4";
}

std::vector<std::string>& anceParser::getRuleNames() const {
  return anceParserStaticData->ruleNames;
}

dfa::Vocabulary const& anceParser::getVocabulary() const
{
    return anceParserStaticData->vocabulary;
}

antlr4::atn::SerializedATNView anceParser::getSerializedATN() const
{
    return anceParserStaticData->serializedATN;
}

//----------------- FileContext ------------------------------------------------------------------

anceParser::FileContext::FileContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{}

tree::TerminalNode* anceParser::FileContext::EOF()
{
    return getToken(anceParser::EOF, 0);
}

std::vector<anceParser::VariableDeclarationContext*> anceParser::FileContext::variableDeclaration()
{
    return getRuleContexts<anceParser::VariableDeclarationContext>();
}

anceParser::VariableDeclarationContext* anceParser::FileContext::variableDeclaration(size_t i)
{
    return getRuleContext<anceParser::VariableDeclarationContext>(i);
}

std::vector<anceParser::FunctionContext*> anceParser::FileContext::function()
{
    return getRuleContexts<anceParser::FunctionContext>();
}

anceParser::FunctionContext* anceParser::FileContext::function(size_t i)
{
    return getRuleContext<anceParser::FunctionContext>(i);
}

std::vector<anceParser::TypeDefinitionContext*> anceParser::FileContext::typeDefinition()
{
    return getRuleContexts<anceParser::TypeDefinitionContext>();
}

anceParser::TypeDefinitionContext* anceParser::FileContext::typeDefinition(size_t i)
{
    return getRuleContext<anceParser::TypeDefinitionContext>(i);
}

size_t anceParser::FileContext::getRuleIndex() const
{
    return anceParser::RuleFile;
}

std::any anceParser::FileContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitFile(this);
    else return visitor->visitChildren(this);
}

anceParser::FileContext* anceParser::file()
{
    FileContext* _localctx = _tracker.createInstance<FileContext>(_ctx, getState());
    enterRule(_localctx, 0, anceParser::RuleFile);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(145);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while ((((_la & ~0x3fULL) == 0)
                && ((1ULL << _la)
                    & ((1ULL << anceParser::T__5) | (1ULL << anceParser::T__10) | (1ULL << anceParser::T__11)))
                       != 0))
        {
            setState(143);
            _errHandler->sync(this);
            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 0, _ctx))
            {
                case 1:
                {
                    setState(140);
                    variableDeclaration();
                    break;
                }

                case 2:
                {
                    setState(141);
                    function();
                    break;
                }

                case 3:
                {
                    setState(142);
                    typeDefinition();
                    break;
                }

                default:
                    break;
            }
            setState(147);
            _errHandler->sync(this);
            _la = _input->LA(1);
        }
        setState(148);
        match(anceParser::EOF);
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- VariableDeclarationContext ------------------------------------------------------------------

anceParser::VariableDeclarationContext::VariableDeclarationContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{}

anceParser::AccessModifierContext* anceParser::VariableDeclarationContext::accessModifier()
{
    return getRuleContext<anceParser::AccessModifierContext>(0);
}

tree::TerminalNode* anceParser::VariableDeclarationContext::IDENTIFIER()
{
    return getToken(anceParser::IDENTIFIER, 0);
}

tree::TerminalNode* anceParser::VariableDeclarationContext::SEMICOLON()
{
    return getToken(anceParser::SEMICOLON, 0);
}

tree::TerminalNode* anceParser::VariableDeclarationContext::CONST()
{
    return getToken(anceParser::CONST, 0);
}

anceParser::TypeContext* anceParser::VariableDeclarationContext::type()
{
    return getRuleContext<anceParser::TypeContext>(0);
}

anceParser::AssignerContext* anceParser::VariableDeclarationContext::assigner()
{
    return getRuleContext<anceParser::AssignerContext>(0);
}

anceParser::ExpressionContext* anceParser::VariableDeclarationContext::expression()
{
    return getRuleContext<anceParser::ExpressionContext>(0);
}

size_t anceParser::VariableDeclarationContext::getRuleIndex() const
{
    return anceParser::RuleVariableDeclaration;
}

std::any anceParser::VariableDeclarationContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitVariableDeclaration(this);
    else return visitor->visitChildren(this);
}

anceParser::VariableDeclarationContext* anceParser::variableDeclaration()
{
    VariableDeclarationContext* _localctx = _tracker.createInstance<VariableDeclarationContext>(_ctx, getState());
    enterRule(_localctx, 2, anceParser::RuleVariableDeclaration);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(150);
        accessModifier();
        setState(152);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == anceParser::CONST)
        {
            setState(151);
            match(anceParser::CONST);
        }
        setState(154);
        match(anceParser::IDENTIFIER);
        setState(157);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == anceParser::T__0)
        {
            setState(155);
            match(anceParser::T__0);
            setState(156);
            type();
        }
        setState(162);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~0x3fULL) == 0)
             && ((1ULL << _la)
                 & ((1ULL << anceParser::T__14) | (1ULL << anceParser::T__15) | (1ULL << anceParser::T__16)))
                    != 0))
        {
            setState(159);
            assigner();
            setState(160);
            expression(0);
        }
        setState(164);
        match(anceParser::SEMICOLON);
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- FunctionContext ------------------------------------------------------------------

anceParser::FunctionContext::FunctionContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{}

size_t anceParser::FunctionContext::getRuleIndex() const
{
    return anceParser::RuleFunction;
}

void anceParser::FunctionContext::copyFrom(FunctionContext* ctx)
{
    ParserRuleContext::copyFrom(ctx);
}

//----------------- ExternFunctionDeclarationContext ------------------------------------------------------------------

tree::TerminalNode* anceParser::ExternFunctionDeclarationContext::IDENTIFIER()
{
    return getToken(anceParser::IDENTIFIER, 0);
}

anceParser::ParametersContext* anceParser::ExternFunctionDeclarationContext::parameters()
{
    return getRuleContext<anceParser::ParametersContext>(0);
}

tree::TerminalNode* anceParser::ExternFunctionDeclarationContext::SEMICOLON()
{
    return getToken(anceParser::SEMICOLON, 0);
}

anceParser::TypeContext* anceParser::ExternFunctionDeclarationContext::type()
{
    return getRuleContext<anceParser::TypeContext>(0);
}

anceParser::ExternFunctionDeclarationContext::ExternFunctionDeclarationContext(FunctionContext* ctx)
{
    copyFrom(ctx);
}

std::any anceParser::ExternFunctionDeclarationContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor))
        return parserVisitor->visitExternFunctionDeclaration(this);
    else return visitor->visitChildren(this);
}
//----------------- FunctionDefinitionContext ------------------------------------------------------------------

anceParser::AccessModifierContext* anceParser::FunctionDefinitionContext::accessModifier()
{
    return getRuleContext<anceParser::AccessModifierContext>(0);
}

tree::TerminalNode* anceParser::FunctionDefinitionContext::IDENTIFIER()
{
    return getToken(anceParser::IDENTIFIER, 0);
}

anceParser::ParametersContext* anceParser::FunctionDefinitionContext::parameters()
{
    return getRuleContext<anceParser::ParametersContext>(0);
}

anceParser::TypeContext* anceParser::FunctionDefinitionContext::type()
{
    return getRuleContext<anceParser::TypeContext>(0);
}

std::vector<anceParser::CodeContext*> anceParser::FunctionDefinitionContext::code()
{
    return getRuleContexts<anceParser::CodeContext>();
}

anceParser::CodeContext* anceParser::FunctionDefinitionContext::code(size_t i)
{
    return getRuleContext<anceParser::CodeContext>(i);
}

anceParser::FunctionDefinitionContext::FunctionDefinitionContext(FunctionContext* ctx)
{
    copyFrom(ctx);
}

std::any anceParser::FunctionDefinitionContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitFunctionDefinition(this);
    else return visitor->visitChildren(this);
}
anceParser::FunctionContext* anceParser::function()
{
    FunctionContext* _localctx = _tracker.createInstance<FunctionContext>(_ctx, getState());
    enterRule(_localctx, 4, anceParser::RuleFunction);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(195);
        _errHandler->sync(this);
        switch (_input->LA(1))
        {
            case anceParser::T__10:
            case anceParser::T__11:
            {
                _localctx = _tracker.createInstance<anceParser::FunctionDefinitionContext>(_localctx);
                enterOuterAlt(_localctx, 1);
                setState(166);
                accessModifier();
                setState(167);
                match(anceParser::IDENTIFIER);
                setState(168);
                match(anceParser::T__1);
                setState(169);
                parameters();
                setState(170);
                match(anceParser::T__2);
                setState(173);
                _errHandler->sync(this);

                _la = _input->LA(1);
                if (_la == anceParser::T__0)
                {
                    setState(171);
                    match(anceParser::T__0);
                    setState(172);
                    type();
                }
                setState(175);
                match(anceParser::T__3);
                setState(179);
                _errHandler->sync(this);
                _la = _input->LA(1);
                while (
                    (((_la & ~0x3fULL) == 0)
                     && ((1ULL << _la)
                         & ((1ULL << anceParser::T__1) | (1ULL << anceParser::T__3) | (1ULL << anceParser::T__12)
                            | (1ULL << anceParser::T__13) | (1ULL << anceParser::T__17) | (1ULL << anceParser::T__18)
                            | (1ULL << anceParser::T__19) | (1ULL << anceParser::T__20) | (1ULL << anceParser::T__23)
                            | (1ULL << anceParser::T__25) | (1ULL << anceParser::T__31) | (1ULL << anceParser::T__35)
                            | (1ULL << anceParser::T__37) | (1ULL << anceParser::T__38) | (1ULL << anceParser::T__39)
                            | (1ULL << anceParser::T__52) | (1ULL << anceParser::T__55) | (1ULL << anceParser::T__56)
                            | (1ULL << anceParser::T__58) | (1ULL << anceParser::T__59) | (1ULL << anceParser::T__60)
                            | (1ULL << anceParser::T__61) | (1ULL << anceParser::T__62)))
                            != 0)
                    || ((((_la - 64) & ~0x3fULL) == 0)
                        && ((1ULL << (_la - 64))
                            & ((1ULL << (anceParser::T__63 - 64)) | (1ULL << (anceParser::T__64 - 64))
                               | (1ULL << (anceParser::T__65 - 64)) | (1ULL << (anceParser::T__66 - 64))
                               | (1ULL << (anceParser::T__67 - 64)) | (1ULL << (anceParser::T__68 - 64))
                               | (1ULL << (anceParser::T__69 - 64)) | (1ULL << (anceParser::T__70 - 64))
                               | (1ULL << (anceParser::T__71 - 64)) | (1ULL << (anceParser::T__72 - 64))
                               | (1ULL << (anceParser::T__73 - 64)) | (1ULL << (anceParser::T__74 - 64))
                               | (1ULL << (anceParser::NATIVE_INTEGER_TYPE - 64))
                               | (1ULL << (anceParser::SIGNED_INTEGER - 64)) | (1ULL << (anceParser::HEX_INTEGER - 64))
                               | (1ULL << (anceParser::BIN_INTEGER - 64)) | (1ULL << (anceParser::OCT_INTEGER - 64))
                               | (1ULL << (anceParser::HALF - 64)) | (1ULL << (anceParser::SINGLE - 64))
                               | (1ULL << (anceParser::DOUBLE - 64)) | (1ULL << (anceParser::QUAD - 64))
                               | (1ULL << (anceParser::STRING - 64)) | (1ULL << (anceParser::CHAR - 64))
                               | (1ULL << (anceParser::INTEGER - 64)) | (1ULL << (anceParser::BUFFER - 64))
                               | (1ULL << (anceParser::NOT - 64)) | (1ULL << (anceParser::IDENTIFIER - 64))))
                               != 0))
                {
                    setState(176);
                    code();
                    setState(181);
                    _errHandler->sync(this);
                    _la = _input->LA(1);
                }
                setState(182);
                match(anceParser::T__4);
                break;
            }

            case anceParser::T__5:
            {
                _localctx = _tracker.createInstance<anceParser::ExternFunctionDeclarationContext>(_localctx);
                enterOuterAlt(_localctx, 2);
                setState(184);
                match(anceParser::T__5);
                setState(185);
                match(anceParser::IDENTIFIER);
                setState(186);
                match(anceParser::T__1);
                setState(187);
                parameters();
                setState(188);
                match(anceParser::T__2);
                setState(191);
                _errHandler->sync(this);

                _la = _input->LA(1);
                if (_la == anceParser::T__0)
                {
                    setState(189);
                    match(anceParser::T__0);
                    setState(190);
                    type();
                }
                setState(193);
                match(anceParser::SEMICOLON);
                break;
            }

            default:
                throw NoViableAltException(this);
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- ParametersContext ------------------------------------------------------------------

anceParser::ParametersContext::ParametersContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{}

std::vector<anceParser::ParameterContext*> anceParser::ParametersContext::parameter()
{
    return getRuleContexts<anceParser::ParameterContext>();
}

anceParser::ParameterContext* anceParser::ParametersContext::parameter(size_t i)
{
    return getRuleContext<anceParser::ParameterContext>(i);
}

size_t anceParser::ParametersContext::getRuleIndex() const
{
    return anceParser::RuleParameters;
}

std::any anceParser::ParametersContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitParameters(this);
    else return visitor->visitChildren(this);
}

anceParser::ParametersContext* anceParser::parameters()
{
    ParametersContext* _localctx = _tracker.createInstance<ParametersContext>(_ctx, getState());
    enterRule(_localctx, 6, anceParser::RuleParameters);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(205);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == anceParser::IDENTIFIER)
        {
            setState(197);
            parameter();
            setState(202);
            _errHandler->sync(this);
            _la = _input->LA(1);
            while (_la == anceParser::T__6)
            {
                setState(198);
                match(anceParser::T__6);
                setState(199);
                parameter();
                setState(204);
                _errHandler->sync(this);
                _la = _input->LA(1);
            }
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- ParameterContext ------------------------------------------------------------------

anceParser::ParameterContext::ParameterContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{}

tree::TerminalNode* anceParser::ParameterContext::IDENTIFIER()
{
    return getToken(anceParser::IDENTIFIER, 0);
}

anceParser::TypeContext* anceParser::ParameterContext::type()
{
    return getRuleContext<anceParser::TypeContext>(0);
}

size_t anceParser::ParameterContext::getRuleIndex() const
{
    return anceParser::RuleParameter;
}

std::any anceParser::ParameterContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitParameter(this);
    else return visitor->visitChildren(this);
}

anceParser::ParameterContext* anceParser::parameter()
{
    ParameterContext* _localctx = _tracker.createInstance<ParameterContext>(_ctx, getState());
    enterRule(_localctx, 8, anceParser::RuleParameter);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(207);
        match(anceParser::IDENTIFIER);
        setState(208);
        match(anceParser::T__0);
        setState(209);
        type();
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- TypeDefinitionContext ------------------------------------------------------------------

anceParser::TypeDefinitionContext::TypeDefinitionContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{}

anceParser::DefineAliasContext* anceParser::TypeDefinitionContext::defineAlias()
{
    return getRuleContext<anceParser::DefineAliasContext>(0);
}

anceParser::StructDefinitionContext* anceParser::TypeDefinitionContext::structDefinition()
{
    return getRuleContext<anceParser::StructDefinitionContext>(0);
}

size_t anceParser::TypeDefinitionContext::getRuleIndex() const
{
    return anceParser::RuleTypeDefinition;
}

std::any anceParser::TypeDefinitionContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitTypeDefinition(this);
    else return visitor->visitChildren(this);
}

anceParser::TypeDefinitionContext* anceParser::typeDefinition()
{
    TypeDefinitionContext* _localctx = _tracker.createInstance<TypeDefinitionContext>(_ctx, getState());
    enterRule(_localctx, 10, anceParser::RuleTypeDefinition);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(213);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 11, _ctx))
        {
            case 1:
            {
                enterOuterAlt(_localctx, 1);
                setState(211);
                defineAlias();
                break;
            }

            case 2:
            {
                enterOuterAlt(_localctx, 2);
                setState(212);
                structDefinition();
                break;
            }

            default:
                break;
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- DefineAliasContext ------------------------------------------------------------------

anceParser::DefineAliasContext::DefineAliasContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{}

anceParser::AccessModifierContext* anceParser::DefineAliasContext::accessModifier()
{
    return getRuleContext<anceParser::AccessModifierContext>(0);
}

tree::TerminalNode* anceParser::DefineAliasContext::IDENTIFIER()
{
    return getToken(anceParser::IDENTIFIER, 0);
}

anceParser::TypeContext* anceParser::DefineAliasContext::type()
{
    return getRuleContext<anceParser::TypeContext>(0);
}

tree::TerminalNode* anceParser::DefineAliasContext::SEMICOLON()
{
    return getToken(anceParser::SEMICOLON, 0);
}

size_t anceParser::DefineAliasContext::getRuleIndex() const
{
    return anceParser::RuleDefineAlias;
}

std::any anceParser::DefineAliasContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitDefineAlias(this);
    else return visitor->visitChildren(this);
}

anceParser::DefineAliasContext* anceParser::defineAlias()
{
    DefineAliasContext* _localctx = _tracker.createInstance<DefineAliasContext>(_ctx, getState());
    enterRule(_localctx, 12, anceParser::RuleDefineAlias);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(215);
        accessModifier();
        setState(216);
        match(anceParser::T__7);
        setState(217);
        match(anceParser::IDENTIFIER);
        setState(218);
        match(anceParser::T__8);
        setState(219);
        type();
        setState(220);
        match(anceParser::SEMICOLON);
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- StructDefinitionContext ------------------------------------------------------------------

anceParser::StructDefinitionContext::StructDefinitionContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{}

anceParser::AccessModifierContext* anceParser::StructDefinitionContext::accessModifier()
{
    return getRuleContext<anceParser::AccessModifierContext>(0);
}

tree::TerminalNode* anceParser::StructDefinitionContext::IDENTIFIER()
{
    return getToken(anceParser::IDENTIFIER, 0);
}

std::vector<anceParser::MemberContext*> anceParser::StructDefinitionContext::member()
{
    return getRuleContexts<anceParser::MemberContext>();
}

anceParser::MemberContext* anceParser::StructDefinitionContext::member(size_t i)
{
    return getRuleContext<anceParser::MemberContext>(i);
}

size_t anceParser::StructDefinitionContext::getRuleIndex() const
{
    return anceParser::RuleStructDefinition;
}

std::any anceParser::StructDefinitionContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitStructDefinition(this);
    else return visitor->visitChildren(this);
}

anceParser::StructDefinitionContext* anceParser::structDefinition()
{
    StructDefinitionContext* _localctx = _tracker.createInstance<StructDefinitionContext>(_ctx, getState());
    enterRule(_localctx, 14, anceParser::RuleStructDefinition);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(222);
        accessModifier();
        setState(223);
        match(anceParser::T__9);
        setState(224);
        match(anceParser::IDENTIFIER);
        setState(225);
        match(anceParser::T__3);
        setState(229);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == anceParser::T__10

               || _la == anceParser::T__11)
        {
            setState(226);
            member();
            setState(231);
            _errHandler->sync(this);
            _la = _input->LA(1);
        }
        setState(232);
        match(anceParser::T__4);
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- MemberContext ------------------------------------------------------------------

anceParser::MemberContext::MemberContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{}

anceParser::AccessModifierContext* anceParser::MemberContext::accessModifier()
{
    return getRuleContext<anceParser::AccessModifierContext>(0);
}

tree::TerminalNode* anceParser::MemberContext::IDENTIFIER()
{
    return getToken(anceParser::IDENTIFIER, 0);
}

anceParser::TypeContext* anceParser::MemberContext::type()
{
    return getRuleContext<anceParser::TypeContext>(0);
}

tree::TerminalNode* anceParser::MemberContext::SEMICOLON()
{
    return getToken(anceParser::SEMICOLON, 0);
}

anceParser::AssignerContext* anceParser::MemberContext::assigner()
{
    return getRuleContext<anceParser::AssignerContext>(0);
}

anceParser::LiteralExpressionContext* anceParser::MemberContext::literalExpression()
{
    return getRuleContext<anceParser::LiteralExpressionContext>(0);
}

size_t anceParser::MemberContext::getRuleIndex() const
{
    return anceParser::RuleMember;
}

std::any anceParser::MemberContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitMember(this);
    else return visitor->visitChildren(this);
}

anceParser::MemberContext* anceParser::member()
{
    MemberContext* _localctx = _tracker.createInstance<MemberContext>(_ctx, getState());
    enterRule(_localctx, 16, anceParser::RuleMember);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(234);
        accessModifier();
        setState(235);
        match(anceParser::IDENTIFIER);
        setState(236);
        match(anceParser::T__0);
        setState(237);
        type();
        setState(241);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~0x3fULL) == 0)
             && ((1ULL << _la)
                 & ((1ULL << anceParser::T__14) | (1ULL << anceParser::T__15) | (1ULL << anceParser::T__16)))
                    != 0))
        {
            setState(238);
            assigner();
            setState(239);
            literalExpression();
        }
        setState(243);
        match(anceParser::SEMICOLON);
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- AccessModifierContext ------------------------------------------------------------------

anceParser::AccessModifierContext::AccessModifierContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{}

size_t anceParser::AccessModifierContext::getRuleIndex() const
{
    return anceParser::RuleAccessModifier;
}

void anceParser::AccessModifierContext::copyFrom(AccessModifierContext* ctx)
{
    ParserRuleContext::copyFrom(ctx);
}

//----------------- PrivateContext ------------------------------------------------------------------

anceParser::PrivateContext::PrivateContext(AccessModifierContext* ctx)
{
    copyFrom(ctx);
}

std::any anceParser::PrivateContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitPrivate(this);
    else return visitor->visitChildren(this);
}
//----------------- PublicContext ------------------------------------------------------------------

anceParser::PublicContext::PublicContext(AccessModifierContext* ctx)
{
    copyFrom(ctx);
}

std::any anceParser::PublicContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitPublic(this);
    else return visitor->visitChildren(this);
}
anceParser::AccessModifierContext* anceParser::accessModifier()
{
    AccessModifierContext* _localctx = _tracker.createInstance<AccessModifierContext>(_ctx, getState());
    enterRule(_localctx, 18, anceParser::RuleAccessModifier);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(247);
        _errHandler->sync(this);
        switch (_input->LA(1))
        {
            case anceParser::T__10:
            {
                _localctx = _tracker.createInstance<anceParser::PublicContext>(_localctx);
                enterOuterAlt(_localctx, 1);
                setState(245);
                match(anceParser::T__10);
                break;
            }

            case anceParser::T__11:
            {
                _localctx = _tracker.createInstance<anceParser::PrivateContext>(_localctx);
                enterOuterAlt(_localctx, 2);
                setState(246);
                match(anceParser::T__11);
                break;
            }

            default:
                throw NoViableAltException(this);
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- CodeContext ------------------------------------------------------------------

anceParser::CodeContext::CodeContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{}

anceParser::StatementContext* anceParser::CodeContext::statement()
{
    return getRuleContext<anceParser::StatementContext>(0);
}

anceParser::BlockContext* anceParser::CodeContext::block()
{
    return getRuleContext<anceParser::BlockContext>(0);
}

size_t anceParser::CodeContext::getRuleIndex() const
{
    return anceParser::RuleCode;
}

std::any anceParser::CodeContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitCode(this);
    else return visitor->visitChildren(this);
}

anceParser::CodeContext* anceParser::code()
{
    CodeContext* _localctx = _tracker.createInstance<CodeContext>(_ctx, getState());
    enterRule(_localctx, 20, anceParser::RuleCode);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(251);
        _errHandler->sync(this);
        switch (_input->LA(1))
        {
            case anceParser::T__1:
            case anceParser::T__12:
            case anceParser::T__13:
            case anceParser::T__17:
            case anceParser::T__18:
            case anceParser::T__19:
            case anceParser::T__20:
            case anceParser::T__23:
            case anceParser::T__25:
            case anceParser::T__31:
            case anceParser::T__35:
            case anceParser::T__37:
            case anceParser::T__38:
            case anceParser::T__39:
            case anceParser::T__52:
            case anceParser::T__55:
            case anceParser::T__56:
            case anceParser::T__58:
            case anceParser::T__59:
            case anceParser::T__60:
            case anceParser::T__61:
            case anceParser::T__62:
            case anceParser::T__63:
            case anceParser::T__64:
            case anceParser::T__65:
            case anceParser::T__66:
            case anceParser::T__67:
            case anceParser::T__68:
            case anceParser::T__69:
            case anceParser::T__70:
            case anceParser::T__71:
            case anceParser::T__72:
            case anceParser::T__73:
            case anceParser::T__74:
            case anceParser::NATIVE_INTEGER_TYPE:
            case anceParser::SIGNED_INTEGER:
            case anceParser::HEX_INTEGER:
            case anceParser::BIN_INTEGER:
            case anceParser::OCT_INTEGER:
            case anceParser::HALF:
            case anceParser::SINGLE:
            case anceParser::DOUBLE:
            case anceParser::QUAD:
            case anceParser::STRING:
            case anceParser::CHAR:
            case anceParser::INTEGER:
            case anceParser::BUFFER:
            case anceParser::NOT:
            case anceParser::IDENTIFIER:
            {
                enterOuterAlt(_localctx, 1);
                setState(249);
                statement();
                break;
            }

            case anceParser::T__3:
            {
                enterOuterAlt(_localctx, 2);
                setState(250);
                block();
                break;
            }

            default:
                throw NoViableAltException(this);
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- BlockContext ------------------------------------------------------------------

anceParser::BlockContext::BlockContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{}

std::vector<anceParser::CodeContext*> anceParser::BlockContext::code()
{
    return getRuleContexts<anceParser::CodeContext>();
}

anceParser::CodeContext* anceParser::BlockContext::code(size_t i)
{
    return getRuleContext<anceParser::CodeContext>(i);
}

size_t anceParser::BlockContext::getRuleIndex() const
{
    return anceParser::RuleBlock;
}

std::any anceParser::BlockContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitBlock(this);
    else return visitor->visitChildren(this);
}

anceParser::BlockContext* anceParser::block()
{
    BlockContext* _localctx = _tracker.createInstance<BlockContext>(_ctx, getState());
    enterRule(_localctx, 22, anceParser::RuleBlock);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(253);
        match(anceParser::T__3);
        setState(257);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while ((((_la & ~0x3fULL) == 0)
                && ((1ULL << _la)
                    & ((1ULL << anceParser::T__1) | (1ULL << anceParser::T__3) | (1ULL << anceParser::T__12)
                       | (1ULL << anceParser::T__13) | (1ULL << anceParser::T__17) | (1ULL << anceParser::T__18)
                       | (1ULL << anceParser::T__19) | (1ULL << anceParser::T__20) | (1ULL << anceParser::T__23)
                       | (1ULL << anceParser::T__25) | (1ULL << anceParser::T__31) | (1ULL << anceParser::T__35)
                       | (1ULL << anceParser::T__37) | (1ULL << anceParser::T__38) | (1ULL << anceParser::T__39)
                       | (1ULL << anceParser::T__52) | (1ULL << anceParser::T__55) | (1ULL << anceParser::T__56)
                       | (1ULL << anceParser::T__58) | (1ULL << anceParser::T__59) | (1ULL << anceParser::T__60)
                       | (1ULL << anceParser::T__61) | (1ULL << anceParser::T__62)))
                       != 0)
               || ((((_la - 64) & ~0x3fULL) == 0)
                   && ((1ULL << (_la - 64))
                       & ((1ULL << (anceParser::T__63 - 64)) | (1ULL << (anceParser::T__64 - 64))
                          | (1ULL << (anceParser::T__65 - 64)) | (1ULL << (anceParser::T__66 - 64))
                          | (1ULL << (anceParser::T__67 - 64)) | (1ULL << (anceParser::T__68 - 64))
                          | (1ULL << (anceParser::T__69 - 64)) | (1ULL << (anceParser::T__70 - 64))
                          | (1ULL << (anceParser::T__71 - 64)) | (1ULL << (anceParser::T__72 - 64))
                          | (1ULL << (anceParser::T__73 - 64)) | (1ULL << (anceParser::T__74 - 64))
                          | (1ULL << (anceParser::NATIVE_INTEGER_TYPE - 64))
                          | (1ULL << (anceParser::SIGNED_INTEGER - 64)) | (1ULL << (anceParser::HEX_INTEGER - 64))
                          | (1ULL << (anceParser::BIN_INTEGER - 64)) | (1ULL << (anceParser::OCT_INTEGER - 64))
                          | (1ULL << (anceParser::HALF - 64)) | (1ULL << (anceParser::SINGLE - 64))
                          | (1ULL << (anceParser::DOUBLE - 64)) | (1ULL << (anceParser::QUAD - 64))
                          | (1ULL << (anceParser::STRING - 64)) | (1ULL << (anceParser::CHAR - 64))
                          | (1ULL << (anceParser::INTEGER - 64)) | (1ULL << (anceParser::BUFFER - 64))
                          | (1ULL << (anceParser::NOT - 64)) | (1ULL << (anceParser::IDENTIFIER - 64))))
                          != 0))
        {
            setState(254);
            code();
            setState(259);
            _errHandler->sync(this);
            _la = _input->LA(1);
        }
        setState(260);
        match(anceParser::T__4);
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- StatementContext ------------------------------------------------------------------

anceParser::StatementContext::StatementContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{}

anceParser::ExpressionStatementContext* anceParser::StatementContext::expressionStatement()
{
    return getRuleContext<anceParser::ExpressionStatementContext>(0);
}

anceParser::LocalVariableDefinitionContext* anceParser::StatementContext::localVariableDefinition()
{
    return getRuleContext<anceParser::LocalVariableDefinitionContext>(0);
}

anceParser::LocalReferenceDefinitionContext* anceParser::StatementContext::localReferenceDefinition()
{
    return getRuleContext<anceParser::LocalReferenceDefinitionContext>(0);
}

anceParser::DropStatementContext* anceParser::StatementContext::dropStatement()
{
    return getRuleContext<anceParser::DropStatementContext>(0);
}

anceParser::AssignmentContext* anceParser::StatementContext::assignment()
{
    return getRuleContext<anceParser::AssignmentContext>(0);
}

anceParser::DeleteStatementContext* anceParser::StatementContext::deleteStatement()
{
    return getRuleContext<anceParser::DeleteStatementContext>(0);
}

anceParser::ReturnStatementContext* anceParser::StatementContext::returnStatement()
{
    return getRuleContext<anceParser::ReturnStatementContext>(0);
}

anceParser::AssertStatementContext* anceParser::StatementContext::assertStatement()
{
    return getRuleContext<anceParser::AssertStatementContext>(0);
}

anceParser::IfStatementContext* anceParser::StatementContext::ifStatement()
{
    return getRuleContext<anceParser::IfStatementContext>(0);
}

anceParser::WhileStatementContext* anceParser::StatementContext::whileStatement()
{
    return getRuleContext<anceParser::WhileStatementContext>(0);
}

anceParser::MatchStatementContext* anceParser::StatementContext::matchStatement()
{
    return getRuleContext<anceParser::MatchStatementContext>(0);
}

size_t anceParser::StatementContext::getRuleIndex() const
{
    return anceParser::RuleStatement;
}

std::any anceParser::StatementContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitStatement(this);
    else return visitor->visitChildren(this);
}

anceParser::StatementContext* anceParser::statement()
{
    StatementContext* _localctx = _tracker.createInstance<StatementContext>(_ctx, getState());
    enterRule(_localctx, 24, anceParser::RuleStatement);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(273);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 17, _ctx))
        {
            case 1:
            {
                enterOuterAlt(_localctx, 1);
                setState(262);
                expressionStatement();
                break;
            }

            case 2:
            {
                enterOuterAlt(_localctx, 2);
                setState(263);
                localVariableDefinition();
                break;
            }

            case 3:
            {
                enterOuterAlt(_localctx, 3);
                setState(264);
                localReferenceDefinition();
                break;
            }

            case 4:
            {
                enterOuterAlt(_localctx, 4);
                setState(265);
                dropStatement();
                break;
            }

            case 5:
            {
                enterOuterAlt(_localctx, 5);
                setState(266);
                assignment();
                break;
            }

            case 6:
            {
                enterOuterAlt(_localctx, 6);
                setState(267);
                deleteStatement();
                break;
            }

            case 7:
            {
                enterOuterAlt(_localctx, 7);
                setState(268);
                returnStatement();
                break;
            }

            case 8:
            {
                enterOuterAlt(_localctx, 8);
                setState(269);
                assertStatement();
                break;
            }

            case 9:
            {
                enterOuterAlt(_localctx, 9);
                setState(270);
                ifStatement();
                break;
            }

            case 10:
            {
                enterOuterAlt(_localctx, 10);
                setState(271);
                whileStatement();
                break;
            }

            case 11:
            {
                enterOuterAlt(_localctx, 11);
                setState(272);
                matchStatement();
                break;
            }

            default:
                break;
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- ExpressionStatementContext ------------------------------------------------------------------

anceParser::ExpressionStatementContext::ExpressionStatementContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{}

anceParser::IndependentExpressionContext* anceParser::ExpressionStatementContext::independentExpression()
{
    return getRuleContext<anceParser::IndependentExpressionContext>(0);
}

tree::TerminalNode* anceParser::ExpressionStatementContext::SEMICOLON()
{
    return getToken(anceParser::SEMICOLON, 0);
}

size_t anceParser::ExpressionStatementContext::getRuleIndex() const
{
    return anceParser::RuleExpressionStatement;
}

std::any anceParser::ExpressionStatementContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitExpressionStatement(this);
    else return visitor->visitChildren(this);
}

anceParser::ExpressionStatementContext* anceParser::expressionStatement()
{
    ExpressionStatementContext* _localctx = _tracker.createInstance<ExpressionStatementContext>(_ctx, getState());
    enterRule(_localctx, 26, anceParser::RuleExpressionStatement);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(275);
        independentExpression();
        setState(276);
        match(anceParser::SEMICOLON);
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- LocalVariableDefinitionContext ------------------------------------------------------------------

anceParser::LocalVariableDefinitionContext::LocalVariableDefinitionContext(ParserRuleContext* parent,
                                                                           size_t             invokingState)
    : ParserRuleContext(parent, invokingState)
{}

tree::TerminalNode* anceParser::LocalVariableDefinitionContext::IDENTIFIER()
{
    return getToken(anceParser::IDENTIFIER, 0);
}

tree::TerminalNode* anceParser::LocalVariableDefinitionContext::SEMICOLON()
{
    return getToken(anceParser::SEMICOLON, 0);
}

anceParser::TypeContext* anceParser::LocalVariableDefinitionContext::type()
{
    return getRuleContext<anceParser::TypeContext>(0);
}

anceParser::AssignerContext* anceParser::LocalVariableDefinitionContext::assigner()
{
    return getRuleContext<anceParser::AssignerContext>(0);
}

anceParser::ExpressionContext* anceParser::LocalVariableDefinitionContext::expression()
{
    return getRuleContext<anceParser::ExpressionContext>(0);
}

size_t anceParser::LocalVariableDefinitionContext::getRuleIndex() const
{
    return anceParser::RuleLocalVariableDefinition;
}

std::any anceParser::LocalVariableDefinitionContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor))
        return parserVisitor->visitLocalVariableDefinition(this);
    else return visitor->visitChildren(this);
}

anceParser::LocalVariableDefinitionContext* anceParser::localVariableDefinition()
{
    LocalVariableDefinitionContext* _localctx =
        _tracker.createInstance<LocalVariableDefinitionContext>(_ctx, getState());
    enterRule(_localctx, 28, anceParser::RuleLocalVariableDefinition);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(278);
        match(anceParser::T__12);
        setState(279);
        match(anceParser::IDENTIFIER);
        setState(282);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == anceParser::T__0)
        {
            setState(280);
            match(anceParser::T__0);
            setState(281);
            type();
        }
        setState(287);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~0x3fULL) == 0)
             && ((1ULL << _la)
                 & ((1ULL << anceParser::T__14) | (1ULL << anceParser::T__15) | (1ULL << anceParser::T__16)))
                    != 0))
        {
            setState(284);
            assigner();
            setState(285);
            expression(0);
        }
        setState(289);
        match(anceParser::SEMICOLON);
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- LocalReferenceDefinitionContext ------------------------------------------------------------------

anceParser::LocalReferenceDefinitionContext::LocalReferenceDefinitionContext(ParserRuleContext* parent,
                                                                             size_t             invokingState)
    : ParserRuleContext(parent, invokingState)
{}

tree::TerminalNode* anceParser::LocalReferenceDefinitionContext::IDENTIFIER()
{
    return getToken(anceParser::IDENTIFIER, 0);
}

anceParser::TypeContext* anceParser::LocalReferenceDefinitionContext::type()
{
    return getRuleContext<anceParser::TypeContext>(0);
}

anceParser::BindRefContext* anceParser::LocalReferenceDefinitionContext::bindRef()
{
    return getRuleContext<anceParser::BindRefContext>(0);
}

tree::TerminalNode* anceParser::LocalReferenceDefinitionContext::SEMICOLON()
{
    return getToken(anceParser::SEMICOLON, 0);
}

size_t anceParser::LocalReferenceDefinitionContext::getRuleIndex() const
{
    return anceParser::RuleLocalReferenceDefinition;
}

std::any anceParser::LocalReferenceDefinitionContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor))
        return parserVisitor->visitLocalReferenceDefinition(this);
    else return visitor->visitChildren(this);
}

anceParser::LocalReferenceDefinitionContext* anceParser::localReferenceDefinition()
{
    LocalReferenceDefinitionContext* _localctx =
        _tracker.createInstance<LocalReferenceDefinitionContext>(_ctx, getState());
    enterRule(_localctx, 30, anceParser::RuleLocalReferenceDefinition);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(291);
        match(anceParser::T__12);
        setState(292);
        match(anceParser::IDENTIFIER);
        setState(293);
        match(anceParser::T__0);
        setState(294);
        type();
        setState(295);
        bindRef();
        setState(296);
        match(anceParser::SEMICOLON);
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- DropStatementContext ------------------------------------------------------------------

anceParser::DropStatementContext::DropStatementContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{}

tree::TerminalNode* anceParser::DropStatementContext::IDENTIFIER()
{
    return getToken(anceParser::IDENTIFIER, 0);
}

tree::TerminalNode* anceParser::DropStatementContext::SEMICOLON()
{
    return getToken(anceParser::SEMICOLON, 0);
}

size_t anceParser::DropStatementContext::getRuleIndex() const
{
    return anceParser::RuleDropStatement;
}

std::any anceParser::DropStatementContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitDropStatement(this);
    else return visitor->visitChildren(this);
}

anceParser::DropStatementContext* anceParser::dropStatement()
{
    DropStatementContext* _localctx = _tracker.createInstance<DropStatementContext>(_ctx, getState());
    enterRule(_localctx, 32, anceParser::RuleDropStatement);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(298);
        match(anceParser::T__13);
        setState(299);
        match(anceParser::IDENTIFIER);
        setState(300);
        match(anceParser::SEMICOLON);
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- AssignmentContext ------------------------------------------------------------------

anceParser::AssignmentContext::AssignmentContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{}

anceParser::AssignerContext* anceParser::AssignmentContext::assigner()
{
    return getRuleContext<anceParser::AssignerContext>(0);
}

tree::TerminalNode* anceParser::AssignmentContext::SEMICOLON()
{
    return getToken(anceParser::SEMICOLON, 0);
}

std::vector<anceParser::ExpressionContext*> anceParser::AssignmentContext::expression()
{
    return getRuleContexts<anceParser::ExpressionContext>();
}

anceParser::ExpressionContext* anceParser::AssignmentContext::expression(size_t i)
{
    return getRuleContext<anceParser::ExpressionContext>(i);
}

size_t anceParser::AssignmentContext::getRuleIndex() const
{
    return anceParser::RuleAssignment;
}

std::any anceParser::AssignmentContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitAssignment(this);
    else return visitor->visitChildren(this);
}

anceParser::AssignmentContext* anceParser::assignment()
{
    AssignmentContext* _localctx = _tracker.createInstance<AssignmentContext>(_ctx, getState());
    enterRule(_localctx, 34, anceParser::RuleAssignment);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(302);
        antlrcpp::downCast<AssignmentContext*>(_localctx)->assignable = expression(0);
        setState(303);
        assigner();
        setState(304);
        antlrcpp::downCast<AssignmentContext*>(_localctx)->assigned = expression(0);
        setState(305);
        match(anceParser::SEMICOLON);
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- AssignerContext ------------------------------------------------------------------

anceParser::AssignerContext::AssignerContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{}

size_t anceParser::AssignerContext::getRuleIndex() const
{
    return anceParser::RuleAssigner;
}

void anceParser::AssignerContext::copyFrom(AssignerContext* ctx)
{
    ParserRuleContext::copyFrom(ctx);
}

//----------------- MoveAssignmentContext ------------------------------------------------------------------

anceParser::MoveAssignmentContext::MoveAssignmentContext(AssignerContext* ctx)
{
    copyFrom(ctx);
}

std::any anceParser::MoveAssignmentContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitMoveAssignment(this);
    else return visitor->visitChildren(this);
}
//----------------- FinalCopyAssignmentContext ------------------------------------------------------------------

anceParser::FinalCopyAssignmentContext::FinalCopyAssignmentContext(AssignerContext* ctx)
{
    copyFrom(ctx);
}

std::any anceParser::FinalCopyAssignmentContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitFinalCopyAssignment(this);
    else return visitor->visitChildren(this);
}
//----------------- CopyAssignmentContext ------------------------------------------------------------------

anceParser::CopyAssignmentContext::CopyAssignmentContext(AssignerContext* ctx)
{
    copyFrom(ctx);
}

std::any anceParser::CopyAssignmentContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitCopyAssignment(this);
    else return visitor->visitChildren(this);
}
anceParser::AssignerContext* anceParser::assigner()
{
    AssignerContext* _localctx = _tracker.createInstance<AssignerContext>(_ctx, getState());
    enterRule(_localctx, 36, anceParser::RuleAssigner);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(310);
        _errHandler->sync(this);
        switch (_input->LA(1))
        {
            case anceParser::T__14:
            {
                _localctx = _tracker.createInstance<anceParser::CopyAssignmentContext>(_localctx);
                enterOuterAlt(_localctx, 1);
                setState(307);
                match(anceParser::T__14);
                break;
            }

            case anceParser::T__15:
            {
                _localctx = _tracker.createInstance<anceParser::MoveAssignmentContext>(_localctx);
                enterOuterAlt(_localctx, 2);
                setState(308);
                match(anceParser::T__15);
                break;
            }

            case anceParser::T__16:
            {
                _localctx = _tracker.createInstance<anceParser::FinalCopyAssignmentContext>(_localctx);
                enterOuterAlt(_localctx, 3);
                setState(309);
                match(anceParser::T__16);
                break;
            }

            default:
                throw NoViableAltException(this);
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- DeleteStatementContext ------------------------------------------------------------------

anceParser::DeleteStatementContext::DeleteStatementContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{}

anceParser::ExpressionContext* anceParser::DeleteStatementContext::expression()
{
    return getRuleContext<anceParser::ExpressionContext>(0);
}

tree::TerminalNode* anceParser::DeleteStatementContext::SEMICOLON()
{
    return getToken(anceParser::SEMICOLON, 0);
}

tree::TerminalNode* anceParser::DeleteStatementContext::BUFFER()
{
    return getToken(anceParser::BUFFER, 0);
}

size_t anceParser::DeleteStatementContext::getRuleIndex() const
{
    return anceParser::RuleDeleteStatement;
}

std::any anceParser::DeleteStatementContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitDeleteStatement(this);
    else return visitor->visitChildren(this);
}

anceParser::DeleteStatementContext* anceParser::deleteStatement()
{
    DeleteStatementContext* _localctx = _tracker.createInstance<DeleteStatementContext>(_ctx, getState());
    enterRule(_localctx, 38, anceParser::RuleDeleteStatement);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(312);
        match(anceParser::T__17);
        setState(314);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 21, _ctx))
        {
            case 1:
            {
                setState(313);
                match(anceParser::BUFFER);
                break;
            }

            default:
                break;
        }
        setState(316);
        expression(0);
        setState(317);
        match(anceParser::SEMICOLON);
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- ReturnStatementContext ------------------------------------------------------------------

anceParser::ReturnStatementContext::ReturnStatementContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{}

tree::TerminalNode* anceParser::ReturnStatementContext::SEMICOLON()
{
    return getToken(anceParser::SEMICOLON, 0);
}

anceParser::ExpressionContext* anceParser::ReturnStatementContext::expression()
{
    return getRuleContext<anceParser::ExpressionContext>(0);
}

size_t anceParser::ReturnStatementContext::getRuleIndex() const
{
    return anceParser::RuleReturnStatement;
}

std::any anceParser::ReturnStatementContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitReturnStatement(this);
    else return visitor->visitChildren(this);
}

anceParser::ReturnStatementContext* anceParser::returnStatement()
{
    ReturnStatementContext* _localctx = _tracker.createInstance<ReturnStatementContext>(_ctx, getState());
    enterRule(_localctx, 40, anceParser::RuleReturnStatement);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(319);
        match(anceParser::T__18);
        setState(321);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~0x3fULL) == 0)
             && ((1ULL << _la)
                 & ((1ULL << anceParser::T__1) | (1ULL << anceParser::T__20) | (1ULL << anceParser::T__25)
                    | (1ULL << anceParser::T__31) | (1ULL << anceParser::T__35) | (1ULL << anceParser::T__37)
                    | (1ULL << anceParser::T__38) | (1ULL << anceParser::T__39) | (1ULL << anceParser::T__52)
                    | (1ULL << anceParser::T__55) | (1ULL << anceParser::T__56) | (1ULL << anceParser::T__58)
                    | (1ULL << anceParser::T__59) | (1ULL << anceParser::T__60) | (1ULL << anceParser::T__61)
                    | (1ULL << anceParser::T__62)))
                    != 0)
            || ((((_la - 64) & ~0x3fULL) == 0)
                && ((1ULL << (_la - 64))
                    & ((1ULL << (anceParser::T__63 - 64)) | (1ULL << (anceParser::T__64 - 64))
                       | (1ULL << (anceParser::T__65 - 64)) | (1ULL << (anceParser::T__66 - 64))
                       | (1ULL << (anceParser::T__67 - 64)) | (1ULL << (anceParser::T__68 - 64))
                       | (1ULL << (anceParser::T__69 - 64)) | (1ULL << (anceParser::T__70 - 64))
                       | (1ULL << (anceParser::T__71 - 64)) | (1ULL << (anceParser::T__72 - 64))
                       | (1ULL << (anceParser::T__73 - 64)) | (1ULL << (anceParser::T__74 - 64))
                       | (1ULL << (anceParser::NATIVE_INTEGER_TYPE - 64)) | (1ULL << (anceParser::SIGNED_INTEGER - 64))
                       | (1ULL << (anceParser::HEX_INTEGER - 64)) | (1ULL << (anceParser::BIN_INTEGER - 64))
                       | (1ULL << (anceParser::OCT_INTEGER - 64)) | (1ULL << (anceParser::HALF - 64))
                       | (1ULL << (anceParser::SINGLE - 64)) | (1ULL << (anceParser::DOUBLE - 64))
                       | (1ULL << (anceParser::QUAD - 64)) | (1ULL << (anceParser::STRING - 64))
                       | (1ULL << (anceParser::CHAR - 64)) | (1ULL << (anceParser::INTEGER - 64))
                       | (1ULL << (anceParser::BUFFER - 64)) | (1ULL << (anceParser::NOT - 64))
                       | (1ULL << (anceParser::IDENTIFIER - 64))))
                       != 0))
        {
            setState(320);
            expression(0);
        }
        setState(323);
        match(anceParser::SEMICOLON);
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- AssertStatementContext ------------------------------------------------------------------

anceParser::AssertStatementContext::AssertStatementContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{}

anceParser::ExpressionContext* anceParser::AssertStatementContext::expression()
{
    return getRuleContext<anceParser::ExpressionContext>(0);
}

tree::TerminalNode* anceParser::AssertStatementContext::SEMICOLON()
{
    return getToken(anceParser::SEMICOLON, 0);
}

size_t anceParser::AssertStatementContext::getRuleIndex() const
{
    return anceParser::RuleAssertStatement;
}

std::any anceParser::AssertStatementContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitAssertStatement(this);
    else return visitor->visitChildren(this);
}

anceParser::AssertStatementContext* anceParser::assertStatement()
{
    AssertStatementContext* _localctx = _tracker.createInstance<AssertStatementContext>(_ctx, getState());
    enterRule(_localctx, 42, anceParser::RuleAssertStatement);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(325);
        match(anceParser::T__19);
        setState(326);
        expression(0);
        setState(327);
        match(anceParser::SEMICOLON);
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- IfStatementContext ------------------------------------------------------------------

anceParser::IfStatementContext::IfStatementContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{}

anceParser::ExpressionContext* anceParser::IfStatementContext::expression()
{
    return getRuleContext<anceParser::ExpressionContext>(0);
}

std::vector<anceParser::CodeContext*> anceParser::IfStatementContext::code()
{
    return getRuleContexts<anceParser::CodeContext>();
}

anceParser::CodeContext* anceParser::IfStatementContext::code(size_t i)
{
    return getRuleContext<anceParser::CodeContext>(i);
}

size_t anceParser::IfStatementContext::getRuleIndex() const
{
    return anceParser::RuleIfStatement;
}

std::any anceParser::IfStatementContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitIfStatement(this);
    else return visitor->visitChildren(this);
}

anceParser::IfStatementContext* anceParser::ifStatement()
{
    IfStatementContext* _localctx = _tracker.createInstance<IfStatementContext>(_ctx, getState());
    enterRule(_localctx, 44, anceParser::RuleIfStatement);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(329);
        match(anceParser::T__20);
        setState(330);
        expression(0);
        setState(331);
        match(anceParser::T__21);
        setState(332);
        antlrcpp::downCast<IfStatementContext*>(_localctx)->ifBlock = code();
        setState(335);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 23, _ctx))
        {
            case 1:
            {
                setState(333);
                match(anceParser::T__22);
                setState(334);
                antlrcpp::downCast<IfStatementContext*>(_localctx)->elseBlock = code();
                break;
            }

            default:
                break;
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- WhileStatementContext ------------------------------------------------------------------

anceParser::WhileStatementContext::WhileStatementContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{}

anceParser::ExpressionContext* anceParser::WhileStatementContext::expression()
{
    return getRuleContext<anceParser::ExpressionContext>(0);
}

anceParser::CodeContext* anceParser::WhileStatementContext::code()
{
    return getRuleContext<anceParser::CodeContext>(0);
}

size_t anceParser::WhileStatementContext::getRuleIndex() const
{
    return anceParser::RuleWhileStatement;
}

std::any anceParser::WhileStatementContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitWhileStatement(this);
    else return visitor->visitChildren(this);
}

anceParser::WhileStatementContext* anceParser::whileStatement()
{
    WhileStatementContext* _localctx = _tracker.createInstance<WhileStatementContext>(_ctx, getState());
    enterRule(_localctx, 46, anceParser::RuleWhileStatement);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(337);
        match(anceParser::T__23);
        setState(338);
        expression(0);
        setState(339);
        match(anceParser::T__24);
        setState(340);
        code();
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- MatchStatementContext ------------------------------------------------------------------

anceParser::MatchStatementContext::MatchStatementContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{}

anceParser::ExpressionContext* anceParser::MatchStatementContext::expression()
{
    return getRuleContext<anceParser::ExpressionContext>(0);
}

std::vector<anceParser::MatchCaseContext*> anceParser::MatchStatementContext::matchCase()
{
    return getRuleContexts<anceParser::MatchCaseContext>();
}

anceParser::MatchCaseContext* anceParser::MatchStatementContext::matchCase(size_t i)
{
    return getRuleContext<anceParser::MatchCaseContext>(i);
}

size_t anceParser::MatchStatementContext::getRuleIndex() const
{
    return anceParser::RuleMatchStatement;
}

std::any anceParser::MatchStatementContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitMatchStatement(this);
    else return visitor->visitChildren(this);
}

anceParser::MatchStatementContext* anceParser::matchStatement()
{
    MatchStatementContext* _localctx = _tracker.createInstance<MatchStatementContext>(_ctx, getState());
    enterRule(_localctx, 48, anceParser::RuleMatchStatement);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(342);
        match(anceParser::T__25);
        setState(343);
        expression(0);
        setState(344);
        match(anceParser::T__26);
        setState(345);
        match(anceParser::T__3);
        setState(349);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (((((_la - 30) & ~0x3fULL) == 0)
                && ((1ULL << (_la - 30))
                    & ((1ULL << (anceParser::T__29 - 30)) | (1ULL << (anceParser::T__59 - 30))
                       | (1ULL << (anceParser::T__60 - 30)) | (1ULL << (anceParser::T__61 - 30))
                       | (1ULL << (anceParser::SIGNED_INTEGER - 30)) | (1ULL << (anceParser::HEX_INTEGER - 30))
                       | (1ULL << (anceParser::BIN_INTEGER - 30)) | (1ULL << (anceParser::OCT_INTEGER - 30))
                       | (1ULL << (anceParser::HALF - 30)) | (1ULL << (anceParser::SINGLE - 30))
                       | (1ULL << (anceParser::DOUBLE - 30)) | (1ULL << (anceParser::QUAD - 30))
                       | (1ULL << (anceParser::STRING - 30)) | (1ULL << (anceParser::CHAR - 30))
                       | (1ULL << (anceParser::INTEGER - 30)) | (1ULL << (anceParser::IDENTIFIER - 30))))
                       != 0))
        {
            setState(346);
            matchCase();
            setState(351);
            _errHandler->sync(this);
            _la = _input->LA(1);
        }
        setState(352);
        match(anceParser::T__4);
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- MatchCaseContext ------------------------------------------------------------------

anceParser::MatchCaseContext::MatchCaseContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{}

size_t anceParser::MatchCaseContext::getRuleIndex() const
{
    return anceParser::RuleMatchCase;
}

void anceParser::MatchCaseContext::copyFrom(MatchCaseContext* ctx)
{
    ParserRuleContext::copyFrom(ctx);
}

//----------------- LiteralCaseContext ------------------------------------------------------------------

std::vector<anceParser::LiteralExpressionContext*> anceParser::LiteralCaseContext::literalExpression()
{
    return getRuleContexts<anceParser::LiteralExpressionContext>();
}

anceParser::LiteralExpressionContext* anceParser::LiteralCaseContext::literalExpression(size_t i)
{
    return getRuleContext<anceParser::LiteralExpressionContext>(i);
}

anceParser::CodeContext* anceParser::LiteralCaseContext::code()
{
    return getRuleContext<anceParser::CodeContext>(0);
}

anceParser::LiteralCaseContext::LiteralCaseContext(MatchCaseContext* ctx)
{
    copyFrom(ctx);
}

std::any anceParser::LiteralCaseContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitLiteralCase(this);
    else return visitor->visitChildren(this);
}
//----------------- DefaultCaseContext ------------------------------------------------------------------

anceParser::CodeContext* anceParser::DefaultCaseContext::code()
{
    return getRuleContext<anceParser::CodeContext>(0);
}

anceParser::DefaultCaseContext::DefaultCaseContext(MatchCaseContext* ctx)
{
    copyFrom(ctx);
}

std::any anceParser::DefaultCaseContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitDefaultCase(this);
    else return visitor->visitChildren(this);
}
anceParser::MatchCaseContext* anceParser::matchCase()
{
    MatchCaseContext* _localctx = _tracker.createInstance<MatchCaseContext>(_ctx, getState());
    enterRule(_localctx, 50, anceParser::RuleMatchCase);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(368);
        _errHandler->sync(this);
        switch (_input->LA(1))
        {
            case anceParser::T__59:
            case anceParser::T__60:
            case anceParser::T__61:
            case anceParser::SIGNED_INTEGER:
            case anceParser::HEX_INTEGER:
            case anceParser::BIN_INTEGER:
            case anceParser::OCT_INTEGER:
            case anceParser::HALF:
            case anceParser::SINGLE:
            case anceParser::DOUBLE:
            case anceParser::QUAD:
            case anceParser::STRING:
            case anceParser::CHAR:
            case anceParser::INTEGER:
            case anceParser::IDENTIFIER:
            {
                _localctx = _tracker.createInstance<anceParser::LiteralCaseContext>(_localctx);
                enterOuterAlt(_localctx, 1);
                setState(354);
                literalExpression();
                setState(359);
                _errHandler->sync(this);
                _la = _input->LA(1);
                while (_la == anceParser::T__27)
                {
                    setState(355);
                    match(anceParser::T__27);
                    setState(356);
                    literalExpression();
                    setState(361);
                    _errHandler->sync(this);
                    _la = _input->LA(1);
                }
                setState(362);
                match(anceParser::T__28);
                setState(363);
                code();
                break;
            }

            case anceParser::T__29:
            {
                _localctx = _tracker.createInstance<anceParser::DefaultCaseContext>(_localctx);
                enterOuterAlt(_localctx, 2);
                setState(365);
                match(anceParser::T__29);
                setState(366);
                match(anceParser::T__28);
                setState(367);
                code();
                break;
            }

            default:
                throw NoViableAltException(this);
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- ExpressionContext ------------------------------------------------------------------

anceParser::ExpressionContext::ExpressionContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{}

size_t anceParser::ExpressionContext::getRuleIndex() const
{
    return anceParser::RuleExpression;
}

void anceParser::ExpressionContext::copyFrom(ExpressionContext* ctx)
{
    ParserRuleContext::copyFrom(ctx);
}

//----------------- IfExpressionContext ------------------------------------------------------------------

std::vector<anceParser::ExpressionContext*> anceParser::IfExpressionContext::expression()
{
    return getRuleContexts<anceParser::ExpressionContext>();
}

anceParser::ExpressionContext* anceParser::IfExpressionContext::expression(size_t i)
{
    return getRuleContext<anceParser::ExpressionContext>(i);
}

anceParser::IfExpressionContext::IfExpressionContext(ExpressionContext* ctx)
{
    copyFrom(ctx);
}

std::any anceParser::IfExpressionContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitIfExpression(this);
    else return visitor->visitChildren(this);
}
//----------------- VariableContext ------------------------------------------------------------------

anceParser::VariableAccessContext* anceParser::VariableContext::variableAccess()
{
    return getRuleContext<anceParser::VariableAccessContext>(0);
}

anceParser::VariableContext::VariableContext(ExpressionContext* ctx)
{
    copyFrom(ctx);
}

std::any anceParser::VariableContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitVariable(this);
    else return visitor->visitChildren(this);
}
//----------------- UnaryOperationContext ------------------------------------------------------------------

anceParser::UnaryOperatorContext* anceParser::UnaryOperationContext::unaryOperator()
{
    return getRuleContext<anceParser::UnaryOperatorContext>(0);
}

anceParser::ExpressionContext* anceParser::UnaryOperationContext::expression()
{
    return getRuleContext<anceParser::ExpressionContext>(0);
}

anceParser::UnaryOperationContext::UnaryOperationContext(ExpressionContext* ctx)
{
    copyFrom(ctx);
}

std::any anceParser::UnaryOperationContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitUnaryOperation(this);
    else return visitor->visitChildren(this);
}
//----------------- BinaryOperationContext ------------------------------------------------------------------

anceParser::BinaryOperatorMultiplicativeContext* anceParser::BinaryOperationContext::binaryOperatorMultiplicative()
{
    return getRuleContext<anceParser::BinaryOperatorMultiplicativeContext>(0);
}

std::vector<anceParser::ExpressionContext*> anceParser::BinaryOperationContext::expression()
{
    return getRuleContexts<anceParser::ExpressionContext>();
}

anceParser::ExpressionContext* anceParser::BinaryOperationContext::expression(size_t i)
{
    return getRuleContext<anceParser::ExpressionContext>(i);
}

anceParser::BinaryOperatorAdditiveContext* anceParser::BinaryOperationContext::binaryOperatorAdditive()
{
    return getRuleContext<anceParser::BinaryOperatorAdditiveContext>(0);
}

anceParser::BinaryOperatorBitwiseContext* anceParser::BinaryOperationContext::binaryOperatorBitwise()
{
    return getRuleContext<anceParser::BinaryOperatorBitwiseContext>(0);
}

anceParser::BinaryOperatorShiftContext* anceParser::BinaryOperationContext::binaryOperatorShift()
{
    return getRuleContext<anceParser::BinaryOperatorShiftContext>(0);
}

anceParser::BinaryOperatorRelationalContext* anceParser::BinaryOperationContext::binaryOperatorRelational()
{
    return getRuleContext<anceParser::BinaryOperatorRelationalContext>(0);
}

anceParser::BinaryOperatorEqualityContext* anceParser::BinaryOperationContext::binaryOperatorEquality()
{
    return getRuleContext<anceParser::BinaryOperatorEqualityContext>(0);
}

anceParser::BinaryOperationContext::BinaryOperationContext(ExpressionContext* ctx)
{
    copyFrom(ctx);
}

std::any anceParser::BinaryOperationContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitBinaryOperation(this);
    else return visitor->visitChildren(this);
}
//----------------- SubscriptContext ------------------------------------------------------------------

std::vector<anceParser::ExpressionContext*> anceParser::SubscriptContext::expression()
{
    return getRuleContexts<anceParser::ExpressionContext>();
}

anceParser::ExpressionContext* anceParser::SubscriptContext::expression(size_t i)
{
    return getRuleContext<anceParser::ExpressionContext>(i);
}

anceParser::SubscriptContext::SubscriptContext(ExpressionContext* ctx)
{
    copyFrom(ctx);
}

std::any anceParser::SubscriptContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitSubscript(this);
    else return visitor->visitChildren(this);
}
//----------------- LogicalOrContext ------------------------------------------------------------------

std::vector<anceParser::ExpressionContext*> anceParser::LogicalOrContext::expression()
{
    return getRuleContexts<anceParser::ExpressionContext>();
}

anceParser::ExpressionContext* anceParser::LogicalOrContext::expression(size_t i)
{
    return getRuleContext<anceParser::ExpressionContext>(i);
}

tree::TerminalNode* anceParser::LogicalOrContext::NOT()
{
    return getToken(anceParser::NOT, 0);
}

anceParser::LogicalOrContext::LogicalOrContext(ExpressionContext* ctx)
{
    copyFrom(ctx);
}

std::any anceParser::LogicalOrContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitLogicalOr(this);
    else return visitor->visitChildren(this);
}
//----------------- MatchContext ------------------------------------------------------------------

anceParser::MatchExpressionContext* anceParser::MatchContext::matchExpression()
{
    return getRuleContext<anceParser::MatchExpressionContext>(0);
}

anceParser::MatchContext::MatchContext(ExpressionContext* ctx)
{
    copyFrom(ctx);
}

std::any anceParser::MatchContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitMatch(this);
    else return visitor->visitChildren(this);
}
//----------------- RefContext ------------------------------------------------------------------

anceParser::BindRefContext* anceParser::RefContext::bindRef()
{
    return getRuleContext<anceParser::BindRefContext>(0);
}

anceParser::RefContext::RefContext(ExpressionContext* ctx)
{
    copyFrom(ctx);
}

std::any anceParser::RefContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitRef(this);
    else return visitor->visitChildren(this);
}
//----------------- IndependentContext ------------------------------------------------------------------

anceParser::IndependentExpressionContext* anceParser::IndependentContext::independentExpression()
{
    return getRuleContext<anceParser::IndependentExpressionContext>(0);
}

anceParser::IndependentContext::IndependentContext(ExpressionContext* ctx)
{
    copyFrom(ctx);
}

std::any anceParser::IndependentContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitIndependent(this);
    else return visitor->visitChildren(this);
}
//----------------- ParenthesisContext ------------------------------------------------------------------

anceParser::ExpressionContext* anceParser::ParenthesisContext::expression()
{
    return getRuleContext<anceParser::ExpressionContext>(0);
}

anceParser::ParenthesisContext::ParenthesisContext(ExpressionContext* ctx)
{
    copyFrom(ctx);
}

std::any anceParser::ParenthesisContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitParenthesis(this);
    else return visitor->visitChildren(this);
}
//----------------- AllocContext ------------------------------------------------------------------

anceParser::AllocationContext* anceParser::AllocContext::allocation()
{
    return getRuleContext<anceParser::AllocationContext>(0);
}

anceParser::AllocContext::AllocContext(ExpressionContext* ctx)
{
    copyFrom(ctx);
}

std::any anceParser::AllocContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitAlloc(this);
    else return visitor->visitChildren(this);
}
//----------------- MemberAccessContext ------------------------------------------------------------------

tree::TerminalNode* anceParser::MemberAccessContext::IDENTIFIER()
{
    return getToken(anceParser::IDENTIFIER, 0);
}

anceParser::ExpressionContext* anceParser::MemberAccessContext::expression()
{
    return getRuleContext<anceParser::ExpressionContext>(0);
}

anceParser::MemberAccessContext::MemberAccessContext(ExpressionContext* ctx)
{
    copyFrom(ctx);
}

std::any anceParser::MemberAccessContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitMemberAccess(this);
    else return visitor->visitChildren(this);
}
//----------------- LiteralContext ------------------------------------------------------------------

anceParser::LiteralExpressionContext* anceParser::LiteralContext::literalExpression()
{
    return getRuleContext<anceParser::LiteralExpressionContext>(0);
}

anceParser::LiteralContext::LiteralContext(ExpressionContext* ctx)
{
    copyFrom(ctx);
}

std::any anceParser::LiteralContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitLiteral(this);
    else return visitor->visitChildren(this);
}
//----------------- LogicalAndContext ------------------------------------------------------------------

std::vector<anceParser::ExpressionContext*> anceParser::LogicalAndContext::expression()
{
    return getRuleContexts<anceParser::ExpressionContext>();
}

anceParser::ExpressionContext* anceParser::LogicalAndContext::expression(size_t i)
{
    return getRuleContext<anceParser::ExpressionContext>(i);
}

tree::TerminalNode* anceParser::LogicalAndContext::NOT()
{
    return getToken(anceParser::NOT, 0);
}

anceParser::LogicalAndContext::LogicalAndContext(ExpressionContext* ctx)
{
    copyFrom(ctx);
}

std::any anceParser::LogicalAndContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitLogicalAnd(this);
    else return visitor->visitChildren(this);
}
//----------------- VectorDefinitionContext ------------------------------------------------------------------

std::vector<anceParser::ExpressionContext*> anceParser::VectorDefinitionContext::expression()
{
    return getRuleContexts<anceParser::ExpressionContext>();
}

anceParser::ExpressionContext* anceParser::VectorDefinitionContext::expression(size_t i)
{
    return getRuleContext<anceParser::ExpressionContext>(i);
}

anceParser::TypeContext* anceParser::VectorDefinitionContext::type()
{
    return getRuleContext<anceParser::TypeContext>(0);
}

anceParser::VectorDefinitionContext::VectorDefinitionContext(ExpressionContext* ctx)
{
    copyFrom(ctx);
}

std::any anceParser::VectorDefinitionContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitVectorDefinition(this);
    else return visitor->visitChildren(this);
}
//----------------- AddressOfContext ------------------------------------------------------------------

anceParser::AddressofContext* anceParser::AddressOfContext::addressof()
{
    return getRuleContext<anceParser::AddressofContext>(0);
}

anceParser::AddressOfContext::AddressOfContext(ExpressionContext* ctx)
{
    copyFrom(ctx);
}

std::any anceParser::AddressOfContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitAddressOf(this);
    else return visitor->visitChildren(this);
}
//----------------- ArrayDefinitionContext ------------------------------------------------------------------

std::vector<anceParser::ExpressionContext*> anceParser::ArrayDefinitionContext::expression()
{
    return getRuleContexts<anceParser::ExpressionContext>();
}

anceParser::ExpressionContext* anceParser::ArrayDefinitionContext::expression(size_t i)
{
    return getRuleContext<anceParser::ExpressionContext>(i);
}

anceParser::TypeContext* anceParser::ArrayDefinitionContext::type()
{
    return getRuleContext<anceParser::TypeContext>(0);
}

anceParser::ArrayDefinitionContext::ArrayDefinitionContext(ExpressionContext* ctx)
{
    copyFrom(ctx);
}

std::any anceParser::ArrayDefinitionContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitArrayDefinition(this);
    else return visitor->visitChildren(this);
}
//----------------- SizeOfContext ------------------------------------------------------------------

anceParser::SizeofTypeContext* anceParser::SizeOfContext::sizeofType()
{
    return getRuleContext<anceParser::SizeofTypeContext>(0);
}

anceParser::SizeofExpressionContext* anceParser::SizeOfContext::sizeofExpression()
{
    return getRuleContext<anceParser::SizeofExpressionContext>(0);
}

anceParser::SizeOfContext::SizeOfContext(ExpressionContext* ctx)
{
    copyFrom(ctx);
}

std::any anceParser::SizeOfContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitSizeOf(this);
    else return visitor->visitChildren(this);
}
//----------------- IndirectionContext ------------------------------------------------------------------

anceParser::ExpressionContext* anceParser::IndirectionContext::expression()
{
    return getRuleContext<anceParser::ExpressionContext>(0);
}

anceParser::IndirectionContext::IndirectionContext(ExpressionContext* ctx)
{
    copyFrom(ctx);
}

std::any anceParser::IndirectionContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitIndirection(this);
    else return visitor->visitChildren(this);
}

anceParser::ExpressionContext* anceParser::expression()
{
    return expression(0);
}

anceParser::ExpressionContext* anceParser::expression(int precedence)
{
    ParserRuleContext*             parentContext   = _ctx;
    size_t                         parentState     = getState();
    anceParser::ExpressionContext* _localctx       = _tracker.createInstance<ExpressionContext>(_ctx, parentState);
    anceParser::ExpressionContext* previousContext = _localctx;
    (void) previousContext;// Silence compiler, in case the context is not used by generated code.
    size_t startState = 52;
    enterRecursionRule(_localctx, 52, anceParser::RuleExpression, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        unrollRecursionContexts(parentContext);
    });
    try
    {
        size_t alt;
        enterOuterAlt(_localctx, 1);
        setState(426);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 31, _ctx))
        {
            case 1:
            {
                _localctx       = _tracker.createInstance<VariableContext>(_localctx);
                _ctx            = _localctx;
                previousContext = _localctx;

                setState(371);
                variableAccess();
                break;
            }

            case 2:
            {
                _localctx       = _tracker.createInstance<AllocContext>(_localctx);
                _ctx            = _localctx;
                previousContext = _localctx;
                setState(372);
                allocation();
                break;
            }

            case 3:
            {
                _localctx       = _tracker.createInstance<LiteralContext>(_localctx);
                _ctx            = _localctx;
                previousContext = _localctx;
                setState(373);
                literalExpression();
                break;
            }

            case 4:
            {
                _localctx       = _tracker.createInstance<AddressOfContext>(_localctx);
                _ctx            = _localctx;
                previousContext = _localctx;
                setState(374);
                addressof();
                break;
            }

            case 5:
            {
                _localctx       = _tracker.createInstance<RefContext>(_localctx);
                _ctx            = _localctx;
                previousContext = _localctx;
                setState(375);
                bindRef();
                break;
            }

            case 6:
            {
                _localctx       = _tracker.createInstance<SizeOfContext>(_localctx);
                _ctx            = _localctx;
                previousContext = _localctx;
                setState(376);
                sizeofType();
                break;
            }

            case 7:
            {
                _localctx       = _tracker.createInstance<SizeOfContext>(_localctx);
                _ctx            = _localctx;
                previousContext = _localctx;
                setState(377);
                sizeofExpression();
                break;
            }

            case 8:
            {
                _localctx       = _tracker.createInstance<IndependentContext>(_localctx);
                _ctx            = _localctx;
                previousContext = _localctx;
                setState(378);
                independentExpression();
                break;
            }

            case 9:
            {
                _localctx       = _tracker.createInstance<ParenthesisContext>(_localctx);
                _ctx            = _localctx;
                previousContext = _localctx;
                setState(379);
                match(anceParser::T__1);
                setState(380);
                expression(0);
                setState(381);
                match(anceParser::T__2);
                break;
            }

            case 10:
            {
                _localctx       = _tracker.createInstance<UnaryOperationContext>(_localctx);
                _ctx            = _localctx;
                previousContext = _localctx;
                setState(383);
                unaryOperator();
                setState(384);
                expression(13);
                break;
            }

            case 11:
            {
                _localctx       = _tracker.createInstance<IfExpressionContext>(_localctx);
                _ctx            = _localctx;
                previousContext = _localctx;
                setState(386);
                match(anceParser::T__20);
                setState(387);
                antlrcpp::downCast<IfExpressionContext*>(_localctx)->condition = expression(0);
                setState(388);
                match(anceParser::T__21);
                setState(389);
                antlrcpp::downCast<IfExpressionContext*>(_localctx)->thenBlock = expression(0);
                setState(390);
                match(anceParser::T__22);
                setState(391);
                antlrcpp::downCast<IfExpressionContext*>(_localctx)->elseBlock = expression(4);
                break;
            }

            case 12:
            {
                _localctx       = _tracker.createInstance<MatchContext>(_localctx);
                _ctx            = _localctx;
                previousContext = _localctx;
                setState(393);
                matchExpression();
                break;
            }

            case 13:
            {
                _localctx       = _tracker.createInstance<VectorDefinitionContext>(_localctx);
                _ctx            = _localctx;
                previousContext = _localctx;
                setState(394);
                match(anceParser::T__35);
                setState(398);
                _errHandler->sync(this);

                switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 27, _ctx))
                {
                    case 1:
                    {
                        setState(395);
                        type();
                        setState(396);
                        match(anceParser::T__27);
                        break;
                    }

                    default:
                        break;
                }
                setState(400);
                expression(0);
                setState(405);
                _errHandler->sync(this);
                _la = _input->LA(1);
                while (_la == anceParser::T__6)
                {
                    setState(401);
                    match(anceParser::T__6);
                    setState(402);
                    expression(0);
                    setState(407);
                    _errHandler->sync(this);
                    _la = _input->LA(1);
                }
                setState(408);
                match(anceParser::T__36);
                break;
            }

            case 14:
            {
                _localctx       = _tracker.createInstance<ArrayDefinitionContext>(_localctx);
                _ctx            = _localctx;
                previousContext = _localctx;
                setState(410);
                match(anceParser::T__31);
                setState(414);
                _errHandler->sync(this);

                switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 29, _ctx))
                {
                    case 1:
                    {
                        setState(411);
                        type();
                        setState(412);
                        match(anceParser::T__27);
                        break;
                    }

                    default:
                        break;
                }
                setState(416);
                expression(0);
                setState(421);
                _errHandler->sync(this);
                _la = _input->LA(1);
                while (_la == anceParser::T__6)
                {
                    setState(417);
                    match(anceParser::T__6);
                    setState(418);
                    expression(0);
                    setState(423);
                    _errHandler->sync(this);
                    _la = _input->LA(1);
                }
                setState(424);
                match(anceParser::T__32);
                break;
            }

            default:
                break;
        }
        _ctx->stop = _input->LT(-1);
        setState(475);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 35, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER)
        {
            if (alt == 1)
            {
                if (!_parseListeners.empty()) triggerExitRuleEvent();
                previousContext = _localctx;
                setState(473);
                _errHandler->sync(this);
                switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 34, _ctx))
                {
                    case 1:
                    {
                        auto newContext = _tracker.createInstance<BinaryOperationContext>(
                            _tracker.createInstance<ExpressionContext>(parentContext, parentState));
                        _localctx        = newContext;
                        newContext->left = previousContext;
                        pushNewRecursionContext(newContext, startState, RuleExpression);
                        setState(428);

                        if (!(precpred(_ctx, 12))) throw FailedPredicateException(this, "precpred(_ctx, 12)");
                        setState(429);
                        binaryOperatorMultiplicative();
                        setState(430);
                        antlrcpp::downCast<BinaryOperationContext*>(_localctx)->right = expression(13);
                        break;
                    }

                    case 2:
                    {
                        auto newContext = _tracker.createInstance<BinaryOperationContext>(
                            _tracker.createInstance<ExpressionContext>(parentContext, parentState));
                        _localctx        = newContext;
                        newContext->left = previousContext;
                        pushNewRecursionContext(newContext, startState, RuleExpression);
                        setState(432);

                        if (!(precpred(_ctx, 11))) throw FailedPredicateException(this, "precpred(_ctx, 11)");
                        setState(433);
                        binaryOperatorAdditive();
                        setState(434);
                        antlrcpp::downCast<BinaryOperationContext*>(_localctx)->right = expression(12);
                        break;
                    }

                    case 3:
                    {
                        auto newContext = _tracker.createInstance<BinaryOperationContext>(
                            _tracker.createInstance<ExpressionContext>(parentContext, parentState));
                        _localctx        = newContext;
                        newContext->left = previousContext;
                        pushNewRecursionContext(newContext, startState, RuleExpression);
                        setState(436);

                        if (!(precpred(_ctx, 10))) throw FailedPredicateException(this, "precpred(_ctx, 10)");
                        setState(437);
                        binaryOperatorBitwise();
                        setState(438);
                        antlrcpp::downCast<BinaryOperationContext*>(_localctx)->right = expression(11);
                        break;
                    }

                    case 4:
                    {
                        auto newContext = _tracker.createInstance<BinaryOperationContext>(
                            _tracker.createInstance<ExpressionContext>(parentContext, parentState));
                        _localctx        = newContext;
                        newContext->left = previousContext;
                        pushNewRecursionContext(newContext, startState, RuleExpression);
                        setState(440);

                        if (!(precpred(_ctx, 9))) throw FailedPredicateException(this, "precpred(_ctx, 9)");
                        setState(441);
                        binaryOperatorShift();
                        setState(442);
                        antlrcpp::downCast<BinaryOperationContext*>(_localctx)->right = expression(10);
                        break;
                    }

                    case 5:
                    {
                        auto newContext = _tracker.createInstance<BinaryOperationContext>(
                            _tracker.createInstance<ExpressionContext>(parentContext, parentState));
                        _localctx        = newContext;
                        newContext->left = previousContext;
                        pushNewRecursionContext(newContext, startState, RuleExpression);
                        setState(444);

                        if (!(precpred(_ctx, 8))) throw FailedPredicateException(this, "precpred(_ctx, 8)");
                        setState(445);
                        binaryOperatorRelational();
                        setState(446);
                        antlrcpp::downCast<BinaryOperationContext*>(_localctx)->right = expression(9);
                        break;
                    }

                    case 6:
                    {
                        auto newContext = _tracker.createInstance<BinaryOperationContext>(
                            _tracker.createInstance<ExpressionContext>(parentContext, parentState));
                        _localctx        = newContext;
                        newContext->left = previousContext;
                        pushNewRecursionContext(newContext, startState, RuleExpression);
                        setState(448);

                        if (!(precpred(_ctx, 7))) throw FailedPredicateException(this, "precpred(_ctx, 7)");
                        setState(449);
                        binaryOperatorEquality();
                        setState(450);
                        antlrcpp::downCast<BinaryOperationContext*>(_localctx)->right = expression(8);
                        break;
                    }

                    case 7:
                    {
                        auto newContext = _tracker.createInstance<LogicalAndContext>(
                            _tracker.createInstance<ExpressionContext>(parentContext, parentState));
                        _localctx        = newContext;
                        newContext->left = previousContext;
                        pushNewRecursionContext(newContext, startState, RuleExpression);
                        setState(452);

                        if (!(precpred(_ctx, 6))) throw FailedPredicateException(this, "precpred(_ctx, 6)");
                        setState(454);
                        _errHandler->sync(this);

                        _la = _input->LA(1);
                        if (_la == anceParser::NOT)
                        {
                            setState(453);
                            match(anceParser::NOT);
                        }
                        setState(456);
                        match(anceParser::T__33);
                        setState(457);
                        antlrcpp::downCast<LogicalAndContext*>(_localctx)->right = expression(7);
                        break;
                    }

                    case 8:
                    {
                        auto newContext = _tracker.createInstance<LogicalOrContext>(
                            _tracker.createInstance<ExpressionContext>(parentContext, parentState));
                        _localctx        = newContext;
                        newContext->left = previousContext;
                        pushNewRecursionContext(newContext, startState, RuleExpression);
                        setState(458);

                        if (!(precpred(_ctx, 5))) throw FailedPredicateException(this, "precpred(_ctx, 5)");
                        setState(460);
                        _errHandler->sync(this);

                        _la = _input->LA(1);
                        if (_la == anceParser::NOT)
                        {
                            setState(459);
                            match(anceParser::NOT);
                        }
                        setState(462);
                        match(anceParser::T__34);
                        setState(463);
                        antlrcpp::downCast<LogicalOrContext*>(_localctx)->right = expression(6);
                        break;
                    }

                    case 9:
                    {
                        auto newContext = _tracker.createInstance<IndirectionContext>(
                            _tracker.createInstance<ExpressionContext>(parentContext, parentState));
                        _localctx         = newContext;
                        newContext->value = previousContext;
                        pushNewRecursionContext(newContext, startState, RuleExpression);
                        setState(464);

                        if (!(precpred(_ctx, 22))) throw FailedPredicateException(this, "precpred(_ctx, 22)");
                        setState(465);
                        match(anceParser::T__30);
                        break;
                    }

                    case 10:
                    {
                        auto newContext = _tracker.createInstance<SubscriptContext>(
                            _tracker.createInstance<ExpressionContext>(parentContext, parentState));
                        _localctx           = newContext;
                        newContext->indexed = previousContext;
                        pushNewRecursionContext(newContext, startState, RuleExpression);
                        setState(466);

                        if (!(precpred(_ctx, 21))) throw FailedPredicateException(this, "precpred(_ctx, 21)");
                        setState(467);
                        match(anceParser::T__31);
                        setState(468);
                        antlrcpp::downCast<SubscriptContext*>(_localctx)->index = expression(0);
                        setState(469);
                        match(anceParser::T__32);
                        break;
                    }

                    case 11:
                    {
                        auto newContext = _tracker.createInstance<MemberAccessContext>(
                            _tracker.createInstance<ExpressionContext>(parentContext, parentState));
                        _localctx            = newContext;
                        newContext->accessed = previousContext;
                        pushNewRecursionContext(newContext, startState, RuleExpression);
                        setState(471);

                        if (!(precpred(_ctx, 20))) throw FailedPredicateException(this, "precpred(_ctx, 20)");
                        setState(472);
                        match(anceParser::IDENTIFIER);
                        break;
                    }

                    default:
                        break;
                }
            }
            setState(477);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 35, _ctx);
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }
    return _localctx;
}

//----------------- UnaryOperatorContext ------------------------------------------------------------------

anceParser::UnaryOperatorContext::UnaryOperatorContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{}

size_t anceParser::UnaryOperatorContext::getRuleIndex() const
{
    return anceParser::RuleUnaryOperator;
}

void anceParser::UnaryOperatorContext::copyFrom(UnaryOperatorContext* ctx)
{
    ParserRuleContext::copyFrom(ctx);
}

//----------------- NotContext ------------------------------------------------------------------

tree::TerminalNode* anceParser::NotContext::NOT()
{
    return getToken(anceParser::NOT, 0);
}

anceParser::NotContext::NotContext(UnaryOperatorContext* ctx)
{
    copyFrom(ctx);
}

std::any anceParser::NotContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitNot(this);
    else return visitor->visitChildren(this);
}
//----------------- NegationContext ------------------------------------------------------------------

anceParser::NegationContext::NegationContext(UnaryOperatorContext* ctx)
{
    copyFrom(ctx);
}

std::any anceParser::NegationContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitNegation(this);
    else return visitor->visitChildren(this);
}
//----------------- BitwiseNotContext ------------------------------------------------------------------

anceParser::BitwiseNotContext::BitwiseNotContext(UnaryOperatorContext* ctx)
{
    copyFrom(ctx);
}

std::any anceParser::BitwiseNotContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitBitwiseNot(this);
    else return visitor->visitChildren(this);
}
anceParser::UnaryOperatorContext* anceParser::unaryOperator()
{
    UnaryOperatorContext* _localctx = _tracker.createInstance<UnaryOperatorContext>(_ctx, getState());
    enterRule(_localctx, 54, anceParser::RuleUnaryOperator);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(481);
        _errHandler->sync(this);
        switch (_input->LA(1))
        {
            case anceParser::NOT:
            {
                _localctx = _tracker.createInstance<anceParser::NotContext>(_localctx);
                enterOuterAlt(_localctx, 1);
                setState(478);
                match(anceParser::NOT);
                break;
            }

            case anceParser::T__37:
            {
                _localctx = _tracker.createInstance<anceParser::BitwiseNotContext>(_localctx);
                enterOuterAlt(_localctx, 2);
                setState(479);
                match(anceParser::T__37);
                break;
            }

            case anceParser::T__38:
            {
                _localctx = _tracker.createInstance<anceParser::NegationContext>(_localctx);
                enterOuterAlt(_localctx, 3);
                setState(480);
                match(anceParser::T__38);
                break;
            }

            default:
                throw NoViableAltException(this);
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- BinaryOperatorMultiplicativeContext ------------------------------------------------------------------

anceParser::BinaryOperatorMultiplicativeContext::BinaryOperatorMultiplicativeContext(ParserRuleContext* parent,
                                                                                     size_t             invokingState)
    : ParserRuleContext(parent, invokingState)
{}

size_t anceParser::BinaryOperatorMultiplicativeContext::getRuleIndex() const
{
    return anceParser::RuleBinaryOperatorMultiplicative;
}

void anceParser::BinaryOperatorMultiplicativeContext::copyFrom(BinaryOperatorMultiplicativeContext* ctx)
{
    ParserRuleContext::copyFrom(ctx);
}

//----------------- MultiplicationContext ------------------------------------------------------------------

anceParser::MultiplicationContext::MultiplicationContext(BinaryOperatorMultiplicativeContext* ctx)
{
    copyFrom(ctx);
}

std::any anceParser::MultiplicationContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitMultiplication(this);
    else return visitor->visitChildren(this);
}
//----------------- DivisionContext ------------------------------------------------------------------

anceParser::DivisionContext::DivisionContext(BinaryOperatorMultiplicativeContext* ctx)
{
    copyFrom(ctx);
}

std::any anceParser::DivisionContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitDivision(this);
    else return visitor->visitChildren(this);
}
//----------------- RemainderContext ------------------------------------------------------------------

anceParser::RemainderContext::RemainderContext(BinaryOperatorMultiplicativeContext* ctx)
{
    copyFrom(ctx);
}

std::any anceParser::RemainderContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitRemainder(this);
    else return visitor->visitChildren(this);
}
anceParser::BinaryOperatorMultiplicativeContext* anceParser::binaryOperatorMultiplicative()
{
    BinaryOperatorMultiplicativeContext* _localctx =
        _tracker.createInstance<BinaryOperatorMultiplicativeContext>(_ctx, getState());
    enterRule(_localctx, 56, anceParser::RuleBinaryOperatorMultiplicative);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(486);
        _errHandler->sync(this);
        switch (_input->LA(1))
        {
            case anceParser::T__39:
            {
                _localctx = _tracker.createInstance<anceParser::MultiplicationContext>(_localctx);
                enterOuterAlt(_localctx, 1);
                setState(483);
                match(anceParser::T__39);
                break;
            }

            case anceParser::T__40:
            {
                _localctx = _tracker.createInstance<anceParser::DivisionContext>(_localctx);
                enterOuterAlt(_localctx, 2);
                setState(484);
                match(anceParser::T__40);
                break;
            }

            case anceParser::T__41:
            {
                _localctx = _tracker.createInstance<anceParser::RemainderContext>(_localctx);
                enterOuterAlt(_localctx, 3);
                setState(485);
                match(anceParser::T__41);
                break;
            }

            default:
                throw NoViableAltException(this);
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- BinaryOperatorAdditiveContext ------------------------------------------------------------------

anceParser::BinaryOperatorAdditiveContext::BinaryOperatorAdditiveContext(ParserRuleContext* parent,
                                                                         size_t             invokingState)
    : ParserRuleContext(parent, invokingState)
{}

size_t anceParser::BinaryOperatorAdditiveContext::getRuleIndex() const
{
    return anceParser::RuleBinaryOperatorAdditive;
}

void anceParser::BinaryOperatorAdditiveContext::copyFrom(BinaryOperatorAdditiveContext* ctx)
{
    ParserRuleContext::copyFrom(ctx);
}

//----------------- AdditionContext ------------------------------------------------------------------

anceParser::AdditionContext::AdditionContext(BinaryOperatorAdditiveContext* ctx)
{
    copyFrom(ctx);
}

std::any anceParser::AdditionContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitAddition(this);
    else return visitor->visitChildren(this);
}
//----------------- SubtractionContext ------------------------------------------------------------------

anceParser::SubtractionContext::SubtractionContext(BinaryOperatorAdditiveContext* ctx)
{
    copyFrom(ctx);
}

std::any anceParser::SubtractionContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitSubtraction(this);
    else return visitor->visitChildren(this);
}
anceParser::BinaryOperatorAdditiveContext* anceParser::binaryOperatorAdditive()
{
    BinaryOperatorAdditiveContext* _localctx = _tracker.createInstance<BinaryOperatorAdditiveContext>(_ctx, getState());
    enterRule(_localctx, 58, anceParser::RuleBinaryOperatorAdditive);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(490);
        _errHandler->sync(this);
        switch (_input->LA(1))
        {
            case anceParser::T__42:
            {
                _localctx = _tracker.createInstance<anceParser::AdditionContext>(_localctx);
                enterOuterAlt(_localctx, 1);
                setState(488);
                match(anceParser::T__42);
                break;
            }

            case anceParser::T__38:
            {
                _localctx = _tracker.createInstance<anceParser::SubtractionContext>(_localctx);
                enterOuterAlt(_localctx, 2);
                setState(489);
                match(anceParser::T__38);
                break;
            }

            default:
                throw NoViableAltException(this);
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- BinaryOperatorBitwiseContext ------------------------------------------------------------------

anceParser::BinaryOperatorBitwiseContext::BinaryOperatorBitwiseContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{}

size_t anceParser::BinaryOperatorBitwiseContext::getRuleIndex() const
{
    return anceParser::RuleBinaryOperatorBitwise;
}

void anceParser::BinaryOperatorBitwiseContext::copyFrom(BinaryOperatorBitwiseContext* ctx)
{
    ParserRuleContext::copyFrom(ctx);
}

//----------------- BitwiseOrContext ------------------------------------------------------------------

anceParser::BitwiseOrContext::BitwiseOrContext(BinaryOperatorBitwiseContext* ctx)
{
    copyFrom(ctx);
}

std::any anceParser::BitwiseOrContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitBitwiseOr(this);
    else return visitor->visitChildren(this);
}
//----------------- BitwiseXorContext ------------------------------------------------------------------

anceParser::BitwiseXorContext::BitwiseXorContext(BinaryOperatorBitwiseContext* ctx)
{
    copyFrom(ctx);
}

std::any anceParser::BitwiseXorContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitBitwiseXor(this);
    else return visitor->visitChildren(this);
}
//----------------- BitwiseAndContext ------------------------------------------------------------------

anceParser::BitwiseAndContext::BitwiseAndContext(BinaryOperatorBitwiseContext* ctx)
{
    copyFrom(ctx);
}

std::any anceParser::BitwiseAndContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitBitwiseAnd(this);
    else return visitor->visitChildren(this);
}
anceParser::BinaryOperatorBitwiseContext* anceParser::binaryOperatorBitwise()
{
    BinaryOperatorBitwiseContext* _localctx = _tracker.createInstance<BinaryOperatorBitwiseContext>(_ctx, getState());
    enterRule(_localctx, 60, anceParser::RuleBinaryOperatorBitwise);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(495);
        _errHandler->sync(this);
        switch (_input->LA(1))
        {
            case anceParser::T__43:
            {
                _localctx = _tracker.createInstance<anceParser::BitwiseAndContext>(_localctx);
                enterOuterAlt(_localctx, 1);
                setState(492);
                match(anceParser::T__43);
                break;
            }

            case anceParser::T__44:
            {
                _localctx = _tracker.createInstance<anceParser::BitwiseOrContext>(_localctx);
                enterOuterAlt(_localctx, 2);
                setState(493);
                match(anceParser::T__44);
                break;
            }

            case anceParser::T__45:
            {
                _localctx = _tracker.createInstance<anceParser::BitwiseXorContext>(_localctx);
                enterOuterAlt(_localctx, 3);
                setState(494);
                match(anceParser::T__45);
                break;
            }

            default:
                throw NoViableAltException(this);
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- BinaryOperatorShiftContext ------------------------------------------------------------------

anceParser::BinaryOperatorShiftContext::BinaryOperatorShiftContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{}

size_t anceParser::BinaryOperatorShiftContext::getRuleIndex() const
{
    return anceParser::RuleBinaryOperatorShift;
}

void anceParser::BinaryOperatorShiftContext::copyFrom(BinaryOperatorShiftContext* ctx)
{
    ParserRuleContext::copyFrom(ctx);
}

//----------------- RightShiftContext ------------------------------------------------------------------

anceParser::RightShiftContext::RightShiftContext(BinaryOperatorShiftContext* ctx)
{
    copyFrom(ctx);
}

std::any anceParser::RightShiftContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitRightShift(this);
    else return visitor->visitChildren(this);
}
//----------------- LeftShiftContext ------------------------------------------------------------------

anceParser::LeftShiftContext::LeftShiftContext(BinaryOperatorShiftContext* ctx)
{
    copyFrom(ctx);
}

std::any anceParser::LeftShiftContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitLeftShift(this);
    else return visitor->visitChildren(this);
}
anceParser::BinaryOperatorShiftContext* anceParser::binaryOperatorShift()
{
    BinaryOperatorShiftContext* _localctx = _tracker.createInstance<BinaryOperatorShiftContext>(_ctx, getState());
    enterRule(_localctx, 62, anceParser::RuleBinaryOperatorShift);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(499);
        _errHandler->sync(this);
        switch (_input->LA(1))
        {
            case anceParser::T__46:
            {
                _localctx = _tracker.createInstance<anceParser::LeftShiftContext>(_localctx);
                enterOuterAlt(_localctx, 1);
                setState(497);
                match(anceParser::T__46);
                break;
            }

            case anceParser::T__47:
            {
                _localctx = _tracker.createInstance<anceParser::RightShiftContext>(_localctx);
                enterOuterAlt(_localctx, 2);
                setState(498);
                match(anceParser::T__47);
                break;
            }

            default:
                throw NoViableAltException(this);
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- BinaryOperatorRelationalContext ------------------------------------------------------------------

anceParser::BinaryOperatorRelationalContext::BinaryOperatorRelationalContext(ParserRuleContext* parent,
                                                                             size_t             invokingState)
    : ParserRuleContext(parent, invokingState)
{}

size_t anceParser::BinaryOperatorRelationalContext::getRuleIndex() const
{
    return anceParser::RuleBinaryOperatorRelational;
}

void anceParser::BinaryOperatorRelationalContext::copyFrom(BinaryOperatorRelationalContext* ctx)
{
    ParserRuleContext::copyFrom(ctx);
}

//----------------- LessThanContext ------------------------------------------------------------------

anceParser::LessThanContext::LessThanContext(BinaryOperatorRelationalContext* ctx)
{
    copyFrom(ctx);
}

std::any anceParser::LessThanContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitLessThan(this);
    else return visitor->visitChildren(this);
}
//----------------- LessThanOrEqualContext ------------------------------------------------------------------

anceParser::LessThanOrEqualContext::LessThanOrEqualContext(BinaryOperatorRelationalContext* ctx)
{
    copyFrom(ctx);
}

std::any anceParser::LessThanOrEqualContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitLessThanOrEqual(this);
    else return visitor->visitChildren(this);
}
//----------------- GreaterThanContext ------------------------------------------------------------------

anceParser::GreaterThanContext::GreaterThanContext(BinaryOperatorRelationalContext* ctx)
{
    copyFrom(ctx);
}

std::any anceParser::GreaterThanContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitGreaterThan(this);
    else return visitor->visitChildren(this);
}
//----------------- GreaterThanOrEqualContext ------------------------------------------------------------------

anceParser::GreaterThanOrEqualContext::GreaterThanOrEqualContext(BinaryOperatorRelationalContext* ctx)
{
    copyFrom(ctx);
}

std::any anceParser::GreaterThanOrEqualContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitGreaterThanOrEqual(this);
    else return visitor->visitChildren(this);
}
anceParser::BinaryOperatorRelationalContext* anceParser::binaryOperatorRelational()
{
    BinaryOperatorRelationalContext* _localctx =
        _tracker.createInstance<BinaryOperatorRelationalContext>(_ctx, getState());
    enterRule(_localctx, 64, anceParser::RuleBinaryOperatorRelational);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(505);
        _errHandler->sync(this);
        switch (_input->LA(1))
        {
            case anceParser::T__35:
            {
                _localctx = _tracker.createInstance<anceParser::LessThanContext>(_localctx);
                enterOuterAlt(_localctx, 1);
                setState(501);
                match(anceParser::T__35);
                break;
            }

            case anceParser::T__48:
            {
                _localctx = _tracker.createInstance<anceParser::LessThanOrEqualContext>(_localctx);
                enterOuterAlt(_localctx, 2);
                setState(502);
                match(anceParser::T__48);
                break;
            }

            case anceParser::T__36:
            {
                _localctx = _tracker.createInstance<anceParser::GreaterThanContext>(_localctx);
                enterOuterAlt(_localctx, 3);
                setState(503);
                match(anceParser::T__36);
                break;
            }

            case anceParser::T__49:
            {
                _localctx = _tracker.createInstance<anceParser::GreaterThanOrEqualContext>(_localctx);
                enterOuterAlt(_localctx, 4);
                setState(504);
                match(anceParser::T__49);
                break;
            }

            default:
                throw NoViableAltException(this);
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- BinaryOperatorEqualityContext ------------------------------------------------------------------

anceParser::BinaryOperatorEqualityContext::BinaryOperatorEqualityContext(ParserRuleContext* parent,
                                                                         size_t             invokingState)
    : ParserRuleContext(parent, invokingState)
{}

size_t anceParser::BinaryOperatorEqualityContext::getRuleIndex() const
{
    return anceParser::RuleBinaryOperatorEquality;
}

void anceParser::BinaryOperatorEqualityContext::copyFrom(BinaryOperatorEqualityContext* ctx)
{
    ParserRuleContext::copyFrom(ctx);
}

//----------------- NotEqualContext ------------------------------------------------------------------

anceParser::NotEqualContext::NotEqualContext(BinaryOperatorEqualityContext* ctx)
{
    copyFrom(ctx);
}

std::any anceParser::NotEqualContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitNotEqual(this);
    else return visitor->visitChildren(this);
}
//----------------- EqualContext ------------------------------------------------------------------

anceParser::EqualContext::EqualContext(BinaryOperatorEqualityContext* ctx)
{
    copyFrom(ctx);
}

std::any anceParser::EqualContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitEqual(this);
    else return visitor->visitChildren(this);
}
anceParser::BinaryOperatorEqualityContext* anceParser::binaryOperatorEquality()
{
    BinaryOperatorEqualityContext* _localctx = _tracker.createInstance<BinaryOperatorEqualityContext>(_ctx, getState());
    enterRule(_localctx, 66, anceParser::RuleBinaryOperatorEquality);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(509);
        _errHandler->sync(this);
        switch (_input->LA(1))
        {
            case anceParser::T__50:
            {
                _localctx = _tracker.createInstance<anceParser::EqualContext>(_localctx);
                enterOuterAlt(_localctx, 1);
                setState(507);
                match(anceParser::T__50);
                break;
            }

            case anceParser::T__51:
            {
                _localctx = _tracker.createInstance<anceParser::NotEqualContext>(_localctx);
                enterOuterAlt(_localctx, 2);
                setState(508);
                match(anceParser::T__51);
                break;
            }

            default:
                throw NoViableAltException(this);
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- IndependentExpressionContext ------------------------------------------------------------------

anceParser::IndependentExpressionContext::IndependentExpressionContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{}

anceParser::FunctionCallContext* anceParser::IndependentExpressionContext::functionCall()
{
    return getRuleContext<anceParser::FunctionCallContext>(0);
}

size_t anceParser::IndependentExpressionContext::getRuleIndex() const
{
    return anceParser::RuleIndependentExpression;
}

std::any anceParser::IndependentExpressionContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor))
        return parserVisitor->visitIndependentExpression(this);
    else return visitor->visitChildren(this);
}

anceParser::IndependentExpressionContext* anceParser::independentExpression()
{
    IndependentExpressionContext* _localctx = _tracker.createInstance<IndependentExpressionContext>(_ctx, getState());
    enterRule(_localctx, 68, anceParser::RuleIndependentExpression);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(511);
        functionCall();
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- FunctionCallContext ------------------------------------------------------------------

anceParser::FunctionCallContext::FunctionCallContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{}

tree::TerminalNode* anceParser::FunctionCallContext::IDENTIFIER()
{
    return getToken(anceParser::IDENTIFIER, 0);
}

anceParser::ArgumentsContext* anceParser::FunctionCallContext::arguments()
{
    return getRuleContext<anceParser::ArgumentsContext>(0);
}

anceParser::TypeContext* anceParser::FunctionCallContext::type()
{
    return getRuleContext<anceParser::TypeContext>(0);
}

size_t anceParser::FunctionCallContext::getRuleIndex() const
{
    return anceParser::RuleFunctionCall;
}

std::any anceParser::FunctionCallContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitFunctionCall(this);
    else return visitor->visitChildren(this);
}

anceParser::FunctionCallContext* anceParser::functionCall()
{
    FunctionCallContext* _localctx = _tracker.createInstance<FunctionCallContext>(_ctx, getState());
    enterRule(_localctx, 70, anceParser::RuleFunctionCall);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(523);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 43, _ctx))
        {
            case 1:
            {
                enterOuterAlt(_localctx, 1);
                setState(513);
                match(anceParser::IDENTIFIER);
                setState(514);
                match(anceParser::T__1);
                setState(515);
                arguments();
                setState(516);
                match(anceParser::T__2);
                break;
            }

            case 2:
            {
                enterOuterAlt(_localctx, 2);
                setState(518);
                type();
                setState(519);
                match(anceParser::T__1);
                setState(520);
                arguments();
                setState(521);
                match(anceParser::T__2);
                break;
            }

            default:
                break;
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- ArgumentsContext ------------------------------------------------------------------

anceParser::ArgumentsContext::ArgumentsContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{}

std::vector<anceParser::ExpressionContext*> anceParser::ArgumentsContext::expression()
{
    return getRuleContexts<anceParser::ExpressionContext>();
}

anceParser::ExpressionContext* anceParser::ArgumentsContext::expression(size_t i)
{
    return getRuleContext<anceParser::ExpressionContext>(i);
}

size_t anceParser::ArgumentsContext::getRuleIndex() const
{
    return anceParser::RuleArguments;
}

std::any anceParser::ArgumentsContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitArguments(this);
    else return visitor->visitChildren(this);
}

anceParser::ArgumentsContext* anceParser::arguments()
{
    ArgumentsContext* _localctx = _tracker.createInstance<ArgumentsContext>(_ctx, getState());
    enterRule(_localctx, 72, anceParser::RuleArguments);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(533);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~0x3fULL) == 0)
             && ((1ULL << _la)
                 & ((1ULL << anceParser::T__1) | (1ULL << anceParser::T__20) | (1ULL << anceParser::T__25)
                    | (1ULL << anceParser::T__31) | (1ULL << anceParser::T__35) | (1ULL << anceParser::T__37)
                    | (1ULL << anceParser::T__38) | (1ULL << anceParser::T__39) | (1ULL << anceParser::T__52)
                    | (1ULL << anceParser::T__55) | (1ULL << anceParser::T__56) | (1ULL << anceParser::T__58)
                    | (1ULL << anceParser::T__59) | (1ULL << anceParser::T__60) | (1ULL << anceParser::T__61)
                    | (1ULL << anceParser::T__62)))
                    != 0)
            || ((((_la - 64) & ~0x3fULL) == 0)
                && ((1ULL << (_la - 64))
                    & ((1ULL << (anceParser::T__63 - 64)) | (1ULL << (anceParser::T__64 - 64))
                       | (1ULL << (anceParser::T__65 - 64)) | (1ULL << (anceParser::T__66 - 64))
                       | (1ULL << (anceParser::T__67 - 64)) | (1ULL << (anceParser::T__68 - 64))
                       | (1ULL << (anceParser::T__69 - 64)) | (1ULL << (anceParser::T__70 - 64))
                       | (1ULL << (anceParser::T__71 - 64)) | (1ULL << (anceParser::T__72 - 64))
                       | (1ULL << (anceParser::T__73 - 64)) | (1ULL << (anceParser::T__74 - 64))
                       | (1ULL << (anceParser::NATIVE_INTEGER_TYPE - 64)) | (1ULL << (anceParser::SIGNED_INTEGER - 64))
                       | (1ULL << (anceParser::HEX_INTEGER - 64)) | (1ULL << (anceParser::BIN_INTEGER - 64))
                       | (1ULL << (anceParser::OCT_INTEGER - 64)) | (1ULL << (anceParser::HALF - 64))
                       | (1ULL << (anceParser::SINGLE - 64)) | (1ULL << (anceParser::DOUBLE - 64))
                       | (1ULL << (anceParser::QUAD - 64)) | (1ULL << (anceParser::STRING - 64))
                       | (1ULL << (anceParser::CHAR - 64)) | (1ULL << (anceParser::INTEGER - 64))
                       | (1ULL << (anceParser::BUFFER - 64)) | (1ULL << (anceParser::NOT - 64))
                       | (1ULL << (anceParser::IDENTIFIER - 64))))
                       != 0))
        {
            setState(525);
            expression(0);
            setState(530);
            _errHandler->sync(this);
            _la = _input->LA(1);
            while (_la == anceParser::T__6)
            {
                setState(526);
                match(anceParser::T__6);
                setState(527);
                expression(0);
                setState(532);
                _errHandler->sync(this);
                _la = _input->LA(1);
            }
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- VariableAccessContext ------------------------------------------------------------------

anceParser::VariableAccessContext::VariableAccessContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{}

tree::TerminalNode* anceParser::VariableAccessContext::IDENTIFIER()
{
    return getToken(anceParser::IDENTIFIER, 0);
}

size_t anceParser::VariableAccessContext::getRuleIndex() const
{
    return anceParser::RuleVariableAccess;
}

std::any anceParser::VariableAccessContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitVariableAccess(this);
    else return visitor->visitChildren(this);
}

anceParser::VariableAccessContext* anceParser::variableAccess()
{
    VariableAccessContext* _localctx = _tracker.createInstance<VariableAccessContext>(_ctx, getState());
    enterRule(_localctx, 74, anceParser::RuleVariableAccess);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(535);
        match(anceParser::IDENTIFIER);
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- AllocationContext ------------------------------------------------------------------

anceParser::AllocationContext::AllocationContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{}

anceParser::AllocatorContext* anceParser::AllocationContext::allocator()
{
    return getRuleContext<anceParser::AllocatorContext>(0);
}

anceParser::TypeContext* anceParser::AllocationContext::type()
{
    return getRuleContext<anceParser::TypeContext>(0);
}

anceParser::ExpressionContext* anceParser::AllocationContext::expression()
{
    return getRuleContext<anceParser::ExpressionContext>(0);
}

size_t anceParser::AllocationContext::getRuleIndex() const
{
    return anceParser::RuleAllocation;
}

std::any anceParser::AllocationContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitAllocation(this);
    else return visitor->visitChildren(this);
}

anceParser::AllocationContext* anceParser::allocation()
{
    AllocationContext* _localctx = _tracker.createInstance<AllocationContext>(_ctx, getState());
    enterRule(_localctx, 76, anceParser::RuleAllocation);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(537);
        match(anceParser::T__52);
        setState(542);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == anceParser::T__31)
        {
            setState(538);
            match(anceParser::T__31);
            setState(539);
            expression(0);
            setState(540);
            match(anceParser::T__32);
        }
        setState(544);
        allocator();
        setState(545);
        type();
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- AllocatorContext ------------------------------------------------------------------

anceParser::AllocatorContext::AllocatorContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{}

size_t anceParser::AllocatorContext::getRuleIndex() const
{
    return anceParser::RuleAllocator;
}

void anceParser::AllocatorContext::copyFrom(AllocatorContext* ctx)
{
    ParserRuleContext::copyFrom(ctx);
}

//----------------- DynamicContext ------------------------------------------------------------------

anceParser::DynamicContext::DynamicContext(AllocatorContext* ctx)
{
    copyFrom(ctx);
}

std::any anceParser::DynamicContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitDynamic(this);
    else return visitor->visitChildren(this);
}
//----------------- AutomaticContext ------------------------------------------------------------------

anceParser::AutomaticContext::AutomaticContext(AllocatorContext* ctx)
{
    copyFrom(ctx);
}

std::any anceParser::AutomaticContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitAutomatic(this);
    else return visitor->visitChildren(this);
}
anceParser::AllocatorContext* anceParser::allocator()
{
    AllocatorContext* _localctx = _tracker.createInstance<AllocatorContext>(_ctx, getState());
    enterRule(_localctx, 78, anceParser::RuleAllocator);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(549);
        _errHandler->sync(this);
        switch (_input->LA(1))
        {
            case anceParser::T__53:
            {
                _localctx = _tracker.createInstance<anceParser::DynamicContext>(_localctx);
                enterOuterAlt(_localctx, 1);
                setState(547);
                match(anceParser::T__53);
                break;
            }

            case anceParser::T__54:
            {
                _localctx = _tracker.createInstance<anceParser::AutomaticContext>(_localctx);
                enterOuterAlt(_localctx, 2);
                setState(548);
                match(anceParser::T__54);
                break;
            }

            default:
                throw NoViableAltException(this);
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- AddressofContext ------------------------------------------------------------------

anceParser::AddressofContext::AddressofContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{}

anceParser::ExpressionContext* anceParser::AddressofContext::expression()
{
    return getRuleContext<anceParser::ExpressionContext>(0);
}

size_t anceParser::AddressofContext::getRuleIndex() const
{
    return anceParser::RuleAddressof;
}

std::any anceParser::AddressofContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitAddressof(this);
    else return visitor->visitChildren(this);
}

anceParser::AddressofContext* anceParser::addressof()
{
    AddressofContext* _localctx = _tracker.createInstance<AddressofContext>(_ctx, getState());
    enterRule(_localctx, 80, anceParser::RuleAddressof);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(551);
        match(anceParser::T__55);
        setState(552);
        expression(0);
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- BindRefContext ------------------------------------------------------------------

anceParser::BindRefContext::BindRefContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{}

size_t anceParser::BindRefContext::getRuleIndex() const
{
    return anceParser::RuleBindRef;
}

void anceParser::BindRefContext::copyFrom(BindRefContext* ctx)
{
    ParserRuleContext::copyFrom(ctx);
}

//----------------- BindReferenceToAddressContext ------------------------------------------------------------------

anceParser::ExpressionContext* anceParser::BindReferenceToAddressContext::expression()
{
    return getRuleContext<anceParser::ExpressionContext>(0);
}

anceParser::BindReferenceToAddressContext::BindReferenceToAddressContext(BindRefContext* ctx)
{
    copyFrom(ctx);
}

std::any anceParser::BindReferenceToAddressContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor))
        return parserVisitor->visitBindReferenceToAddress(this);
    else return visitor->visitChildren(this);
}
//----------------- BindReferenceContext ------------------------------------------------------------------

anceParser::ExpressionContext* anceParser::BindReferenceContext::expression()
{
    return getRuleContext<anceParser::ExpressionContext>(0);
}

anceParser::BindReferenceContext::BindReferenceContext(BindRefContext* ctx)
{
    copyFrom(ctx);
}

std::any anceParser::BindReferenceContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitBindReference(this);
    else return visitor->visitChildren(this);
}
anceParser::BindRefContext* anceParser::bindRef()
{
    BindRefContext* _localctx = _tracker.createInstance<BindRefContext>(_ctx, getState());
    enterRule(_localctx, 82, anceParser::RuleBindRef);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(559);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 48, _ctx))
        {
            case 1:
            {
                _localctx = _tracker.createInstance<anceParser::BindReferenceContext>(_localctx);
                enterOuterAlt(_localctx, 1);
                setState(554);
                match(anceParser::T__56);
                setState(555);
                expression(0);
                break;
            }

            case 2:
            {
                _localctx = _tracker.createInstance<anceParser::BindReferenceToAddressContext>(_localctx);
                enterOuterAlt(_localctx, 2);
                setState(556);
                match(anceParser::T__56);
                setState(557);
                match(anceParser::T__57);
                setState(558);
                expression(0);
                break;
            }

            default:
                break;
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- SizeofTypeContext ------------------------------------------------------------------

anceParser::SizeofTypeContext::SizeofTypeContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{}

anceParser::TypeContext* anceParser::SizeofTypeContext::type()
{
    return getRuleContext<anceParser::TypeContext>(0);
}

size_t anceParser::SizeofTypeContext::getRuleIndex() const
{
    return anceParser::RuleSizeofType;
}

std::any anceParser::SizeofTypeContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitSizeofType(this);
    else return visitor->visitChildren(this);
}

anceParser::SizeofTypeContext* anceParser::sizeofType()
{
    SizeofTypeContext* _localctx = _tracker.createInstance<SizeofTypeContext>(_ctx, getState());
    enterRule(_localctx, 84, anceParser::RuleSizeofType);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(561);
        match(anceParser::T__58);
        setState(562);
        type();
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- SizeofExpressionContext ------------------------------------------------------------------

anceParser::SizeofExpressionContext::SizeofExpressionContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{}

anceParser::ExpressionContext* anceParser::SizeofExpressionContext::expression()
{
    return getRuleContext<anceParser::ExpressionContext>(0);
}

size_t anceParser::SizeofExpressionContext::getRuleIndex() const
{
    return anceParser::RuleSizeofExpression;
}

std::any anceParser::SizeofExpressionContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitSizeofExpression(this);
    else return visitor->visitChildren(this);
}

anceParser::SizeofExpressionContext* anceParser::sizeofExpression()
{
    SizeofExpressionContext* _localctx = _tracker.createInstance<SizeofExpressionContext>(_ctx, getState());
    enterRule(_localctx, 86, anceParser::RuleSizeofExpression);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(564);
        match(anceParser::T__58);
        setState(565);
        match(anceParser::T__1);
        setState(566);
        expression(0);
        setState(567);
        match(anceParser::T__2);
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- MatchExpressionContext ------------------------------------------------------------------

anceParser::MatchExpressionContext::MatchExpressionContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{}

anceParser::ExpressionContext* anceParser::MatchExpressionContext::expression()
{
    return getRuleContext<anceParser::ExpressionContext>(0);
}

std::vector<anceParser::MatchExpressionCaseContext*> anceParser::MatchExpressionContext::matchExpressionCase()
{
    return getRuleContexts<anceParser::MatchExpressionCaseContext>();
}

anceParser::MatchExpressionCaseContext* anceParser::MatchExpressionContext::matchExpressionCase(size_t i)
{
    return getRuleContext<anceParser::MatchExpressionCaseContext>(i);
}

size_t anceParser::MatchExpressionContext::getRuleIndex() const
{
    return anceParser::RuleMatchExpression;
}

std::any anceParser::MatchExpressionContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitMatchExpression(this);
    else return visitor->visitChildren(this);
}

anceParser::MatchExpressionContext* anceParser::matchExpression()
{
    MatchExpressionContext* _localctx = _tracker.createInstance<MatchExpressionContext>(_ctx, getState());
    enterRule(_localctx, 88, anceParser::RuleMatchExpression);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(569);
        match(anceParser::T__25);
        setState(570);
        antlrcpp::downCast<MatchExpressionContext*>(_localctx)->condition = expression(0);
        setState(571);
        match(anceParser::T__26);
        setState(572);
        match(anceParser::T__3);
        setState(581);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (((((_la - 30) & ~0x3fULL) == 0)
             && ((1ULL << (_la - 30))
                 & ((1ULL << (anceParser::T__29 - 30)) | (1ULL << (anceParser::T__59 - 30))
                    | (1ULL << (anceParser::T__60 - 30)) | (1ULL << (anceParser::T__61 - 30))
                    | (1ULL << (anceParser::SIGNED_INTEGER - 30)) | (1ULL << (anceParser::HEX_INTEGER - 30))
                    | (1ULL << (anceParser::BIN_INTEGER - 30)) | (1ULL << (anceParser::OCT_INTEGER - 30))
                    | (1ULL << (anceParser::HALF - 30)) | (1ULL << (anceParser::SINGLE - 30))
                    | (1ULL << (anceParser::DOUBLE - 30)) | (1ULL << (anceParser::QUAD - 30))
                    | (1ULL << (anceParser::STRING - 30)) | (1ULL << (anceParser::CHAR - 30))
                    | (1ULL << (anceParser::INTEGER - 30)) | (1ULL << (anceParser::IDENTIFIER - 30))))
                    != 0))
        {
            setState(573);
            matchExpressionCase();
            setState(578);
            _errHandler->sync(this);
            _la = _input->LA(1);
            while (_la == anceParser::T__6)
            {
                setState(574);
                match(anceParser::T__6);
                setState(575);
                matchExpressionCase();
                setState(580);
                _errHandler->sync(this);
                _la = _input->LA(1);
            }
        }
        setState(583);
        match(anceParser::T__4);
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- MatchExpressionCaseContext ------------------------------------------------------------------

anceParser::MatchExpressionCaseContext::MatchExpressionCaseContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{}

size_t anceParser::MatchExpressionCaseContext::getRuleIndex() const
{
    return anceParser::RuleMatchExpressionCase;
}

void anceParser::MatchExpressionCaseContext::copyFrom(MatchExpressionCaseContext* ctx)
{
    ParserRuleContext::copyFrom(ctx);
}

//----------------- LiteralExpressionCaseContext ------------------------------------------------------------------

std::vector<anceParser::LiteralExpressionContext*> anceParser::LiteralExpressionCaseContext::literalExpression()
{
    return getRuleContexts<anceParser::LiteralExpressionContext>();
}

anceParser::LiteralExpressionContext* anceParser::LiteralExpressionCaseContext::literalExpression(size_t i)
{
    return getRuleContext<anceParser::LiteralExpressionContext>(i);
}

anceParser::ExpressionContext* anceParser::LiteralExpressionCaseContext::expression()
{
    return getRuleContext<anceParser::ExpressionContext>(0);
}

anceParser::LiteralExpressionCaseContext::LiteralExpressionCaseContext(MatchExpressionCaseContext* ctx)
{
    copyFrom(ctx);
}

std::any anceParser::LiteralExpressionCaseContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor))
        return parserVisitor->visitLiteralExpressionCase(this);
    else return visitor->visitChildren(this);
}
//----------------- DefaultExpressionCaseContext ------------------------------------------------------------------

anceParser::ExpressionContext* anceParser::DefaultExpressionCaseContext::expression()
{
    return getRuleContext<anceParser::ExpressionContext>(0);
}

anceParser::DefaultExpressionCaseContext::DefaultExpressionCaseContext(MatchExpressionCaseContext* ctx)
{
    copyFrom(ctx);
}

std::any anceParser::DefaultExpressionCaseContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor))
        return parserVisitor->visitDefaultExpressionCase(this);
    else return visitor->visitChildren(this);
}
anceParser::MatchExpressionCaseContext* anceParser::matchExpressionCase()
{
    MatchExpressionCaseContext* _localctx = _tracker.createInstance<MatchExpressionCaseContext>(_ctx, getState());
    enterRule(_localctx, 90, anceParser::RuleMatchExpressionCase);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(599);
        _errHandler->sync(this);
        switch (_input->LA(1))
        {
            case anceParser::T__59:
            case anceParser::T__60:
            case anceParser::T__61:
            case anceParser::SIGNED_INTEGER:
            case anceParser::HEX_INTEGER:
            case anceParser::BIN_INTEGER:
            case anceParser::OCT_INTEGER:
            case anceParser::HALF:
            case anceParser::SINGLE:
            case anceParser::DOUBLE:
            case anceParser::QUAD:
            case anceParser::STRING:
            case anceParser::CHAR:
            case anceParser::INTEGER:
            case anceParser::IDENTIFIER:
            {
                _localctx = _tracker.createInstance<anceParser::LiteralExpressionCaseContext>(_localctx);
                enterOuterAlt(_localctx, 1);
                setState(585);
                literalExpression();
                setState(590);
                _errHandler->sync(this);
                _la = _input->LA(1);
                while (_la == anceParser::T__27)
                {
                    setState(586);
                    match(anceParser::T__27);
                    setState(587);
                    literalExpression();
                    setState(592);
                    _errHandler->sync(this);
                    _la = _input->LA(1);
                }
                setState(593);
                match(anceParser::T__28);
                setState(594);
                expression(0);
                break;
            }

            case anceParser::T__29:
            {
                _localctx = _tracker.createInstance<anceParser::DefaultExpressionCaseContext>(_localctx);
                enterOuterAlt(_localctx, 2);
                setState(596);
                match(anceParser::T__29);
                setState(597);
                match(anceParser::T__28);
                setState(598);
                expression(0);
                break;
            }

            default:
                throw NoViableAltException(this);
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- LiteralExpressionContext ------------------------------------------------------------------

anceParser::LiteralExpressionContext::LiteralExpressionContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{}

anceParser::StringLiteralContext* anceParser::LiteralExpressionContext::stringLiteral()
{
    return getRuleContext<anceParser::StringLiteralContext>(0);
}

anceParser::CharLiteralContext* anceParser::LiteralExpressionContext::charLiteral()
{
    return getRuleContext<anceParser::CharLiteralContext>(0);
}

anceParser::IntegerLiteralContext* anceParser::LiteralExpressionContext::integerLiteral()
{
    return getRuleContext<anceParser::IntegerLiteralContext>(0);
}

anceParser::FloatingPointLiteralContext* anceParser::LiteralExpressionContext::floatingPointLiteral()
{
    return getRuleContext<anceParser::FloatingPointLiteralContext>(0);
}

anceParser::BooleanLiteralContext* anceParser::LiteralExpressionContext::booleanLiteral()
{
    return getRuleContext<anceParser::BooleanLiteralContext>(0);
}

anceParser::NullLiteralContext* anceParser::LiteralExpressionContext::nullLiteral()
{
    return getRuleContext<anceParser::NullLiteralContext>(0);
}

anceParser::SizeLiteralContext* anceParser::LiteralExpressionContext::sizeLiteral()
{
    return getRuleContext<anceParser::SizeLiteralContext>(0);
}

anceParser::DiffLiteralContext* anceParser::LiteralExpressionContext::diffLiteral()
{
    return getRuleContext<anceParser::DiffLiteralContext>(0);
}

anceParser::UiptrLiteralContext* anceParser::LiteralExpressionContext::uiptrLiteral()
{
    return getRuleContext<anceParser::UiptrLiteralContext>(0);
}

size_t anceParser::LiteralExpressionContext::getRuleIndex() const
{
    return anceParser::RuleLiteralExpression;
}

std::any anceParser::LiteralExpressionContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitLiteralExpression(this);
    else return visitor->visitChildren(this);
}

anceParser::LiteralExpressionContext* anceParser::literalExpression()
{
    LiteralExpressionContext* _localctx = _tracker.createInstance<LiteralExpressionContext>(_ctx, getState());
    enterRule(_localctx, 92, anceParser::RuleLiteralExpression);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(610);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 53, _ctx))
        {
            case 1:
            {
                enterOuterAlt(_localctx, 1);
                setState(601);
                stringLiteral();
                break;
            }

            case 2:
            {
                enterOuterAlt(_localctx, 2);
                setState(602);
                charLiteral();
                break;
            }

            case 3:
            {
                enterOuterAlt(_localctx, 3);
                setState(603);
                integerLiteral();
                break;
            }

            case 4:
            {
                enterOuterAlt(_localctx, 4);
                setState(604);
                floatingPointLiteral();
                break;
            }

            case 5:
            {
                enterOuterAlt(_localctx, 5);
                setState(605);
                booleanLiteral();
                break;
            }

            case 6:
            {
                enterOuterAlt(_localctx, 6);
                setState(606);
                nullLiteral();
                break;
            }

            case 7:
            {
                enterOuterAlt(_localctx, 7);
                setState(607);
                sizeLiteral();
                break;
            }

            case 8:
            {
                enterOuterAlt(_localctx, 8);
                setState(608);
                diffLiteral();
                break;
            }

            case 9:
            {
                enterOuterAlt(_localctx, 9);
                setState(609);
                uiptrLiteral();
                break;
            }

            default:
                break;
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- StringLiteralContext ------------------------------------------------------------------

anceParser::StringLiteralContext::StringLiteralContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{}

tree::TerminalNode* anceParser::StringLiteralContext::STRING()
{
    return getToken(anceParser::STRING, 0);
}

tree::TerminalNode* anceParser::StringLiteralContext::IDENTIFIER()
{
    return getToken(anceParser::IDENTIFIER, 0);
}

tree::TerminalNode* anceParser::StringLiteralContext::INTEGER()
{
    return getToken(anceParser::INTEGER, 0);
}

size_t anceParser::StringLiteralContext::getRuleIndex() const
{
    return anceParser::RuleStringLiteral;
}

std::any anceParser::StringLiteralContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitStringLiteral(this);
    else return visitor->visitChildren(this);
}

anceParser::StringLiteralContext* anceParser::stringLiteral()
{
    StringLiteralContext* _localctx = _tracker.createInstance<StringLiteralContext>(_ctx, getState());
    enterRule(_localctx, 94, anceParser::RuleStringLiteral);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(613);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == anceParser::INTEGER

            || _la == anceParser::IDENTIFIER)
        {
            setState(612);
            antlrcpp::downCast<StringLiteralContext*>(_localctx)->prefix = _input->LT(1);
            _la                                                          = _input->LA(1);
            if (!(_la == anceParser::INTEGER

                  || _la == anceParser::IDENTIFIER))
            {
                antlrcpp::downCast<StringLiteralContext*>(_localctx)->prefix = _errHandler->recoverInline(this);
            }
            else
            {
                _errHandler->reportMatch(this);
                consume();
            }
        }
        setState(615);
        match(anceParser::STRING);
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- CharLiteralContext ------------------------------------------------------------------

anceParser::CharLiteralContext::CharLiteralContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{}

tree::TerminalNode* anceParser::CharLiteralContext::CHAR()
{
    return getToken(anceParser::CHAR, 0);
}

tree::TerminalNode* anceParser::CharLiteralContext::IDENTIFIER()
{
    return getToken(anceParser::IDENTIFIER, 0);
}

tree::TerminalNode* anceParser::CharLiteralContext::INTEGER()
{
    return getToken(anceParser::INTEGER, 0);
}

size_t anceParser::CharLiteralContext::getRuleIndex() const
{
    return anceParser::RuleCharLiteral;
}

std::any anceParser::CharLiteralContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitCharLiteral(this);
    else return visitor->visitChildren(this);
}

anceParser::CharLiteralContext* anceParser::charLiteral()
{
    CharLiteralContext* _localctx = _tracker.createInstance<CharLiteralContext>(_ctx, getState());
    enterRule(_localctx, 96, anceParser::RuleCharLiteral);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(618);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == anceParser::INTEGER

            || _la == anceParser::IDENTIFIER)
        {
            setState(617);
            antlrcpp::downCast<CharLiteralContext*>(_localctx)->prefix = _input->LT(1);
            _la                                                        = _input->LA(1);
            if (!(_la == anceParser::INTEGER

                  || _la == anceParser::IDENTIFIER))
            {
                antlrcpp::downCast<CharLiteralContext*>(_localctx)->prefix = _errHandler->recoverInline(this);
            }
            else
            {
                _errHandler->reportMatch(this);
                consume();
            }
        }
        setState(620);
        match(anceParser::CHAR);
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- IntegerLiteralContext ------------------------------------------------------------------

anceParser::IntegerLiteralContext::IntegerLiteralContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{}

anceParser::NormalIntegerContext* anceParser::IntegerLiteralContext::normalInteger()
{
    return getRuleContext<anceParser::NormalIntegerContext>(0);
}

anceParser::SpecialIntegerContext* anceParser::IntegerLiteralContext::specialInteger()
{
    return getRuleContext<anceParser::SpecialIntegerContext>(0);
}

size_t anceParser::IntegerLiteralContext::getRuleIndex() const
{
    return anceParser::RuleIntegerLiteral;
}

std::any anceParser::IntegerLiteralContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitIntegerLiteral(this);
    else return visitor->visitChildren(this);
}

anceParser::IntegerLiteralContext* anceParser::integerLiteral()
{
    IntegerLiteralContext* _localctx = _tracker.createInstance<IntegerLiteralContext>(_ctx, getState());
    enterRule(_localctx, 98, anceParser::RuleIntegerLiteral);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(624);
        _errHandler->sync(this);
        switch (_input->LA(1))
        {
            case anceParser::SIGNED_INTEGER:
            case anceParser::INTEGER:
            {
                enterOuterAlt(_localctx, 1);
                setState(622);
                normalInteger();
                break;
            }

            case anceParser::HEX_INTEGER:
            case anceParser::BIN_INTEGER:
            case anceParser::OCT_INTEGER:
            {
                enterOuterAlt(_localctx, 2);
                setState(623);
                specialInteger();
                break;
            }

            default:
                throw NoViableAltException(this);
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- NormalIntegerContext ------------------------------------------------------------------

anceParser::NormalIntegerContext::NormalIntegerContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{}

std::vector<tree::TerminalNode*> anceParser::NormalIntegerContext::INTEGER()
{
    return getTokens(anceParser::INTEGER);
}

tree::TerminalNode* anceParser::NormalIntegerContext::INTEGER(size_t i)
{
    return getToken(anceParser::INTEGER, i);
}

tree::TerminalNode* anceParser::NormalIntegerContext::SIGNED_INTEGER()
{
    return getToken(anceParser::SIGNED_INTEGER, 0);
}

size_t anceParser::NormalIntegerContext::getRuleIndex() const
{
    return anceParser::RuleNormalInteger;
}

std::any anceParser::NormalIntegerContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitNormalInteger(this);
    else return visitor->visitChildren(this);
}

anceParser::NormalIntegerContext* anceParser::normalInteger()
{
    NormalIntegerContext* _localctx = _tracker.createInstance<NormalIntegerContext>(_ctx, getState());
    enterRule(_localctx, 100, anceParser::RuleNormalInteger);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(628);
        _errHandler->sync(this);
        switch (_input->LA(1))
        {
            case anceParser::INTEGER:
            {
                setState(626);
                antlrcpp::downCast<NormalIntegerContext*>(_localctx)->uvalue = match(anceParser::INTEGER);
                break;
            }

            case anceParser::SIGNED_INTEGER:
            {
                setState(627);
                antlrcpp::downCast<NormalIntegerContext*>(_localctx)->svalue = match(anceParser::SIGNED_INTEGER);
                break;
            }

            default:
                throw NoViableAltException(this);
        }
        setState(632);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 58, _ctx))
        {
            case 1:
            {
                setState(630);
                match(anceParser::T__0);
                setState(631);
                antlrcpp::downCast<NormalIntegerContext*>(_localctx)->width = match(anceParser::INTEGER);
                break;
            }

            default:
                break;
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- SpecialIntegerContext ------------------------------------------------------------------

anceParser::SpecialIntegerContext::SpecialIntegerContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{}

tree::TerminalNode* anceParser::SpecialIntegerContext::HEX_INTEGER()
{
    return getToken(anceParser::HEX_INTEGER, 0);
}

tree::TerminalNode* anceParser::SpecialIntegerContext::INTEGER()
{
    return getToken(anceParser::INTEGER, 0);
}

tree::TerminalNode* anceParser::SpecialIntegerContext::BIN_INTEGER()
{
    return getToken(anceParser::BIN_INTEGER, 0);
}

tree::TerminalNode* anceParser::SpecialIntegerContext::OCT_INTEGER()
{
    return getToken(anceParser::OCT_INTEGER, 0);
}

size_t anceParser::SpecialIntegerContext::getRuleIndex() const
{
    return anceParser::RuleSpecialInteger;
}

std::any anceParser::SpecialIntegerContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitSpecialInteger(this);
    else return visitor->visitChildren(this);
}

anceParser::SpecialIntegerContext* anceParser::specialInteger()
{
    SpecialIntegerContext* _localctx = _tracker.createInstance<SpecialIntegerContext>(_ctx, getState());
    enterRule(_localctx, 102, anceParser::RuleSpecialInteger);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(643);
        _errHandler->sync(this);
        switch (_input->LA(1))
        {
            case anceParser::HEX_INTEGER:
            {
                enterOuterAlt(_localctx, 1);
                setState(634);
                match(anceParser::HEX_INTEGER);
                setState(635);
                match(anceParser::T__0);
                setState(636);
                antlrcpp::downCast<SpecialIntegerContext*>(_localctx)->width = match(anceParser::INTEGER);
                break;
            }

            case anceParser::BIN_INTEGER:
            {
                enterOuterAlt(_localctx, 2);
                setState(637);
                match(anceParser::BIN_INTEGER);
                setState(638);
                match(anceParser::T__0);
                setState(639);
                antlrcpp::downCast<SpecialIntegerContext*>(_localctx)->width = match(anceParser::INTEGER);
                break;
            }

            case anceParser::OCT_INTEGER:
            {
                enterOuterAlt(_localctx, 3);
                setState(640);
                match(anceParser::OCT_INTEGER);
                setState(641);
                match(anceParser::T__0);
                setState(642);
                antlrcpp::downCast<SpecialIntegerContext*>(_localctx)->width = match(anceParser::INTEGER);
                break;
            }

            default:
                throw NoViableAltException(this);
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- FloatingPointLiteralContext ------------------------------------------------------------------

anceParser::FloatingPointLiteralContext::FloatingPointLiteralContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{}

tree::TerminalNode* anceParser::FloatingPointLiteralContext::HALF()
{
    return getToken(anceParser::HALF, 0);
}

tree::TerminalNode* anceParser::FloatingPointLiteralContext::SINGLE()
{
    return getToken(anceParser::SINGLE, 0);
}

tree::TerminalNode* anceParser::FloatingPointLiteralContext::DOUBLE()
{
    return getToken(anceParser::DOUBLE, 0);
}

tree::TerminalNode* anceParser::FloatingPointLiteralContext::QUAD()
{
    return getToken(anceParser::QUAD, 0);
}

size_t anceParser::FloatingPointLiteralContext::getRuleIndex() const
{
    return anceParser::RuleFloatingPointLiteral;
}

std::any anceParser::FloatingPointLiteralContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitFloatingPointLiteral(this);
    else return visitor->visitChildren(this);
}

anceParser::FloatingPointLiteralContext* anceParser::floatingPointLiteral()
{
    FloatingPointLiteralContext* _localctx = _tracker.createInstance<FloatingPointLiteralContext>(_ctx, getState());
    enterRule(_localctx, 104, anceParser::RuleFloatingPointLiteral);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(645);
        _la = _input->LA(1);
        if (!(((((_la - 81) & ~0x3fULL) == 0)
               && ((1ULL << (_la - 81))
                   & ((1ULL << (anceParser::HALF - 81)) | (1ULL << (anceParser::SINGLE - 81))
                      | (1ULL << (anceParser::DOUBLE - 81)) | (1ULL << (anceParser::QUAD - 81))))
                      != 0)))
        {
            _errHandler->recoverInline(this);
        }
        else
        {
            _errHandler->reportMatch(this);
            consume();
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- BooleanLiteralContext ------------------------------------------------------------------

anceParser::BooleanLiteralContext::BooleanLiteralContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{}

size_t anceParser::BooleanLiteralContext::getRuleIndex() const
{
    return anceParser::RuleBooleanLiteral;
}

void anceParser::BooleanLiteralContext::copyFrom(BooleanLiteralContext* ctx)
{
    ParserRuleContext::copyFrom(ctx);
}

//----------------- TrueContext ------------------------------------------------------------------

anceParser::TrueContext::TrueContext(BooleanLiteralContext* ctx)
{
    copyFrom(ctx);
}

std::any anceParser::TrueContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitTrue(this);
    else return visitor->visitChildren(this);
}
//----------------- FalseContext ------------------------------------------------------------------

anceParser::FalseContext::FalseContext(BooleanLiteralContext* ctx)
{
    copyFrom(ctx);
}

std::any anceParser::FalseContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitFalse(this);
    else return visitor->visitChildren(this);
}
anceParser::BooleanLiteralContext* anceParser::booleanLiteral()
{
    BooleanLiteralContext* _localctx = _tracker.createInstance<BooleanLiteralContext>(_ctx, getState());
    enterRule(_localctx, 106, anceParser::RuleBooleanLiteral);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(649);
        _errHandler->sync(this);
        switch (_input->LA(1))
        {
            case anceParser::T__59:
            {
                _localctx = _tracker.createInstance<anceParser::TrueContext>(_localctx);
                enterOuterAlt(_localctx, 1);
                setState(647);
                match(anceParser::T__59);
                break;
            }

            case anceParser::T__60:
            {
                _localctx = _tracker.createInstance<anceParser::FalseContext>(_localctx);
                enterOuterAlt(_localctx, 2);
                setState(648);
                match(anceParser::T__60);
                break;
            }

            default:
                throw NoViableAltException(this);
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- NullLiteralContext ------------------------------------------------------------------

anceParser::NullLiteralContext::NullLiteralContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{}

size_t anceParser::NullLiteralContext::getRuleIndex() const
{
    return anceParser::RuleNullLiteral;
}

void anceParser::NullLiteralContext::copyFrom(NullLiteralContext* ctx)
{
    ParserRuleContext::copyFrom(ctx);
}

//----------------- NullContext ------------------------------------------------------------------

anceParser::NullContext::NullContext(NullLiteralContext* ctx)
{
    copyFrom(ctx);
}

std::any anceParser::NullContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitNull(this);
    else return visitor->visitChildren(this);
}
anceParser::NullLiteralContext* anceParser::nullLiteral()
{
    NullLiteralContext* _localctx = _tracker.createInstance<NullLiteralContext>(_ctx, getState());
    enterRule(_localctx, 108, anceParser::RuleNullLiteral);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        _localctx = _tracker.createInstance<anceParser::NullContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(651);
        match(anceParser::T__61);
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- SizeLiteralContext ------------------------------------------------------------------

anceParser::SizeLiteralContext::SizeLiteralContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{}

tree::TerminalNode* anceParser::SizeLiteralContext::INTEGER()
{
    return getToken(anceParser::INTEGER, 0);
}

size_t anceParser::SizeLiteralContext::getRuleIndex() const
{
    return anceParser::RuleSizeLiteral;
}

std::any anceParser::SizeLiteralContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitSizeLiteral(this);
    else return visitor->visitChildren(this);
}

anceParser::SizeLiteralContext* anceParser::sizeLiteral()
{
    SizeLiteralContext* _localctx = _tracker.createInstance<SizeLiteralContext>(_ctx, getState());
    enterRule(_localctx, 110, anceParser::RuleSizeLiteral);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(653);
        match(anceParser::INTEGER);
        setState(654);
        match(anceParser::T__0);
        setState(655);
        match(anceParser::T__62);
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- DiffLiteralContext ------------------------------------------------------------------

anceParser::DiffLiteralContext::DiffLiteralContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{}

tree::TerminalNode* anceParser::DiffLiteralContext::SIGNED_INTEGER()
{
    return getToken(anceParser::SIGNED_INTEGER, 0);
}

size_t anceParser::DiffLiteralContext::getRuleIndex() const
{
    return anceParser::RuleDiffLiteral;
}

std::any anceParser::DiffLiteralContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitDiffLiteral(this);
    else return visitor->visitChildren(this);
}

anceParser::DiffLiteralContext* anceParser::diffLiteral()
{
    DiffLiteralContext* _localctx = _tracker.createInstance<DiffLiteralContext>(_ctx, getState());
    enterRule(_localctx, 112, anceParser::RuleDiffLiteral);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(657);
        match(anceParser::SIGNED_INTEGER);
        setState(658);
        match(anceParser::T__0);
        setState(659);
        match(anceParser::T__63);
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- UiptrLiteralContext ------------------------------------------------------------------

anceParser::UiptrLiteralContext::UiptrLiteralContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{}

tree::TerminalNode* anceParser::UiptrLiteralContext::HEX_INTEGER()
{
    return getToken(anceParser::HEX_INTEGER, 0);
}

size_t anceParser::UiptrLiteralContext::getRuleIndex() const
{
    return anceParser::RuleUiptrLiteral;
}

std::any anceParser::UiptrLiteralContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitUiptrLiteral(this);
    else return visitor->visitChildren(this);
}

anceParser::UiptrLiteralContext* anceParser::uiptrLiteral()
{
    UiptrLiteralContext* _localctx = _tracker.createInstance<UiptrLiteralContext>(_ctx, getState());
    enterRule(_localctx, 114, anceParser::RuleUiptrLiteral);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(661);
        match(anceParser::HEX_INTEGER);
        setState(662);
        match(anceParser::T__0);
        setState(663);
        match(anceParser::T__64);
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- TypeContext ------------------------------------------------------------------

anceParser::TypeContext::TypeContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{}

size_t anceParser::TypeContext::getRuleIndex() const
{
    return anceParser::RuleType;
}

void anceParser::TypeContext::copyFrom(TypeContext* ctx)
{
    ParserRuleContext::copyFrom(ctx);
}

//----------------- IntegerContext ------------------------------------------------------------------

anceParser::IntegerTypeContext* anceParser::IntegerContext::integerType()
{
    return getRuleContext<anceParser::IntegerTypeContext>(0);
}

anceParser::IntegerContext::IntegerContext(TypeContext* ctx)
{
    copyFrom(ctx);
}

std::any anceParser::IntegerContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitInteger(this);
    else return visitor->visitChildren(this);
}
//----------------- ArrayContext ------------------------------------------------------------------

anceParser::ArrayTypeContext* anceParser::ArrayContext::arrayType()
{
    return getRuleContext<anceParser::ArrayTypeContext>(0);
}

anceParser::ArrayContext::ArrayContext(TypeContext* ctx)
{
    copyFrom(ctx);
}

std::any anceParser::ArrayContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitArray(this);
    else return visitor->visitChildren(this);
}
//----------------- BufferContext ------------------------------------------------------------------

tree::TerminalNode* anceParser::BufferContext::BUFFER()
{
    return getToken(anceParser::BUFFER, 0);
}

anceParser::TypeContext* anceParser::BufferContext::type()
{
    return getRuleContext<anceParser::TypeContext>(0);
}

anceParser::BufferContext::BufferContext(TypeContext* ctx)
{
    copyFrom(ctx);
}

std::any anceParser::BufferContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitBuffer(this);
    else return visitor->visitChildren(this);
}
//----------------- KeywordContext ------------------------------------------------------------------

anceParser::KeywordTypeContext* anceParser::KeywordContext::keywordType()
{
    return getRuleContext<anceParser::KeywordTypeContext>(0);
}

anceParser::KeywordContext::KeywordContext(TypeContext* ctx)
{
    copyFrom(ctx);
}

std::any anceParser::KeywordContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitKeyword(this);
    else return visitor->visitChildren(this);
}
//----------------- ReferenceContext ------------------------------------------------------------------

anceParser::TypeContext* anceParser::ReferenceContext::type()
{
    return getRuleContext<anceParser::TypeContext>(0);
}

anceParser::ReferenceContext::ReferenceContext(TypeContext* ctx)
{
    copyFrom(ctx);
}

std::any anceParser::ReferenceContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitReference(this);
    else return visitor->visitChildren(this);
}
//----------------- PointerContext ------------------------------------------------------------------

anceParser::TypeContext* anceParser::PointerContext::type()
{
    return getRuleContext<anceParser::TypeContext>(0);
}

anceParser::PointerContext::PointerContext(TypeContext* ctx)
{
    copyFrom(ctx);
}

std::any anceParser::PointerContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitPointer(this);
    else return visitor->visitChildren(this);
}
//----------------- CustomContext ------------------------------------------------------------------

anceParser::CustomTypeContext* anceParser::CustomContext::customType()
{
    return getRuleContext<anceParser::CustomTypeContext>(0);
}

anceParser::CustomContext::CustomContext(TypeContext* ctx)
{
    copyFrom(ctx);
}

std::any anceParser::CustomContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitCustom(this);
    else return visitor->visitChildren(this);
}
//----------------- VectorContext ------------------------------------------------------------------

anceParser::VectorTypeContext* anceParser::VectorContext::vectorType()
{
    return getRuleContext<anceParser::VectorTypeContext>(0);
}

anceParser::VectorContext::VectorContext(TypeContext* ctx)
{
    copyFrom(ctx);
}

std::any anceParser::VectorContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitVector(this);
    else return visitor->visitChildren(this);
}
anceParser::TypeContext* anceParser::type()
{
    TypeContext* _localctx = _tracker.createInstance<TypeContext>(_ctx, getState());
    enterRule(_localctx, 116, anceParser::RuleType);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(676);
        _errHandler->sync(this);
        switch (_input->LA(1))
        {
            case anceParser::NATIVE_INTEGER_TYPE:
            {
                _localctx = _tracker.createInstance<anceParser::IntegerContext>(_localctx);
                enterOuterAlt(_localctx, 1);
                setState(665);
                integerType();
                break;
            }

            case anceParser::T__31:
            {
                _localctx = _tracker.createInstance<anceParser::ArrayContext>(_localctx);
                enterOuterAlt(_localctx, 2);
                setState(666);
                arrayType();
                break;
            }

            case anceParser::T__35:
            {
                _localctx = _tracker.createInstance<anceParser::VectorContext>(_localctx);
                enterOuterAlt(_localctx, 3);
                setState(667);
                vectorType();
                break;
            }

            case anceParser::T__62:
            case anceParser::T__63:
            case anceParser::T__64:
            case anceParser::T__66:
            case anceParser::T__67:
            case anceParser::T__68:
            case anceParser::T__69:
            case anceParser::T__70:
            case anceParser::T__71:
            case anceParser::T__72:
            case anceParser::T__73:
            case anceParser::T__74:
            {
                _localctx = _tracker.createInstance<anceParser::KeywordContext>(_localctx);
                enterOuterAlt(_localctx, 4);
                setState(668);
                keywordType();
                break;
            }

            case anceParser::T__39:
            {
                _localctx = _tracker.createInstance<anceParser::PointerContext>(_localctx);
                enterOuterAlt(_localctx, 5);
                setState(669);
                match(anceParser::T__39);
                setState(670);
                type();
                break;
            }

            case anceParser::BUFFER:
            {
                _localctx = _tracker.createInstance<anceParser::BufferContext>(_localctx);
                enterOuterAlt(_localctx, 6);
                setState(671);
                match(anceParser::BUFFER);
                setState(672);
                type();
                break;
            }

            case anceParser::T__65:
            {
                _localctx = _tracker.createInstance<anceParser::ReferenceContext>(_localctx);
                enterOuterAlt(_localctx, 7);
                setState(673);
                match(anceParser::T__65);
                setState(674);
                type();
                break;
            }

            case anceParser::IDENTIFIER:
            {
                _localctx = _tracker.createInstance<anceParser::CustomContext>(_localctx);
                enterOuterAlt(_localctx, 8);
                setState(675);
                customType();
                break;
            }

            default:
                throw NoViableAltException(this);
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- IntegerTypeContext ------------------------------------------------------------------

anceParser::IntegerTypeContext::IntegerTypeContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{}

tree::TerminalNode* anceParser::IntegerTypeContext::NATIVE_INTEGER_TYPE()
{
    return getToken(anceParser::NATIVE_INTEGER_TYPE, 0);
}

size_t anceParser::IntegerTypeContext::getRuleIndex() const
{
    return anceParser::RuleIntegerType;
}

std::any anceParser::IntegerTypeContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitIntegerType(this);
    else return visitor->visitChildren(this);
}

anceParser::IntegerTypeContext* anceParser::integerType()
{
    IntegerTypeContext* _localctx = _tracker.createInstance<IntegerTypeContext>(_ctx, getState());
    enterRule(_localctx, 118, anceParser::RuleIntegerType);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(678);
        match(anceParser::NATIVE_INTEGER_TYPE);
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- ArrayTypeContext ------------------------------------------------------------------

anceParser::ArrayTypeContext::ArrayTypeContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{}

anceParser::TypeContext* anceParser::ArrayTypeContext::type()
{
    return getRuleContext<anceParser::TypeContext>(0);
}

tree::TerminalNode* anceParser::ArrayTypeContext::SEMICOLON()
{
    return getToken(anceParser::SEMICOLON, 0);
}

tree::TerminalNode* anceParser::ArrayTypeContext::INTEGER()
{
    return getToken(anceParser::INTEGER, 0);
}

size_t anceParser::ArrayTypeContext::getRuleIndex() const
{
    return anceParser::RuleArrayType;
}

std::any anceParser::ArrayTypeContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitArrayType(this);
    else return visitor->visitChildren(this);
}

anceParser::ArrayTypeContext* anceParser::arrayType()
{
    ArrayTypeContext* _localctx = _tracker.createInstance<ArrayTypeContext>(_ctx, getState());
    enterRule(_localctx, 120, anceParser::RuleArrayType);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(680);
        match(anceParser::T__31);
        setState(681);
        type();
        setState(682);
        match(anceParser::SEMICOLON);
        setState(683);
        match(anceParser::INTEGER);
        setState(684);
        match(anceParser::T__32);
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- VectorTypeContext ------------------------------------------------------------------

anceParser::VectorTypeContext::VectorTypeContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{}

anceParser::TypeContext* anceParser::VectorTypeContext::type()
{
    return getRuleContext<anceParser::TypeContext>(0);
}

tree::TerminalNode* anceParser::VectorTypeContext::SEMICOLON()
{
    return getToken(anceParser::SEMICOLON, 0);
}

tree::TerminalNode* anceParser::VectorTypeContext::INTEGER()
{
    return getToken(anceParser::INTEGER, 0);
}

size_t anceParser::VectorTypeContext::getRuleIndex() const
{
    return anceParser::RuleVectorType;
}

std::any anceParser::VectorTypeContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitVectorType(this);
    else return visitor->visitChildren(this);
}

anceParser::VectorTypeContext* anceParser::vectorType()
{
    VectorTypeContext* _localctx = _tracker.createInstance<VectorTypeContext>(_ctx, getState());
    enterRule(_localctx, 122, anceParser::RuleVectorType);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(686);
        match(anceParser::T__35);
        setState(687);
        type();
        setState(688);
        match(anceParser::SEMICOLON);
        setState(689);
        match(anceParser::INTEGER);
        setState(690);
        match(anceParser::T__36);
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- KeywordTypeContext ------------------------------------------------------------------

anceParser::KeywordTypeContext::KeywordTypeContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{}

anceParser::FloatingPointTypeContext* anceParser::KeywordTypeContext::floatingPointType()
{
    return getRuleContext<anceParser::FloatingPointTypeContext>(0);
}

anceParser::TargetDependentTypeContext* anceParser::KeywordTypeContext::targetDependentType()
{
    return getRuleContext<anceParser::TargetDependentTypeContext>(0);
}

anceParser::BooleanTypeContext* anceParser::KeywordTypeContext::booleanType()
{
    return getRuleContext<anceParser::BooleanTypeContext>(0);
}

anceParser::CharTypeContext* anceParser::KeywordTypeContext::charType()
{
    return getRuleContext<anceParser::CharTypeContext>(0);
}

anceParser::NullPointerTypeContext* anceParser::KeywordTypeContext::nullPointerType()
{
    return getRuleContext<anceParser::NullPointerTypeContext>(0);
}

anceParser::VoidTypeContext* anceParser::KeywordTypeContext::voidType()
{
    return getRuleContext<anceParser::VoidTypeContext>(0);
}

size_t anceParser::KeywordTypeContext::getRuleIndex() const
{
    return anceParser::RuleKeywordType;
}

std::any anceParser::KeywordTypeContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitKeywordType(this);
    else return visitor->visitChildren(this);
}

anceParser::KeywordTypeContext* anceParser::keywordType()
{
    KeywordTypeContext* _localctx = _tracker.createInstance<KeywordTypeContext>(_ctx, getState());
    enterRule(_localctx, 124, anceParser::RuleKeywordType);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        setState(698);
        _errHandler->sync(this);
        switch (_input->LA(1))
        {
            case anceParser::T__66:
            case anceParser::T__67:
            case anceParser::T__68:
            case anceParser::T__69:
            {
                enterOuterAlt(_localctx, 1);
                setState(692);
                floatingPointType();
                break;
            }

            case anceParser::T__62:
            case anceParser::T__63:
            case anceParser::T__64:
            case anceParser::T__70:
            {
                enterOuterAlt(_localctx, 2);
                setState(693);
                targetDependentType();
                break;
            }

            case anceParser::T__71:
            {
                enterOuterAlt(_localctx, 3);
                setState(694);
                booleanType();
                break;
            }

            case anceParser::T__72:
            {
                enterOuterAlt(_localctx, 4);
                setState(695);
                charType();
                break;
            }

            case anceParser::T__73:
            {
                enterOuterAlt(_localctx, 5);
                setState(696);
                nullPointerType();
                break;
            }

            case anceParser::T__74:
            {
                enterOuterAlt(_localctx, 6);
                setState(697);
                voidType();
                break;
            }

            default:
                throw NoViableAltException(this);
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- FloatingPointTypeContext ------------------------------------------------------------------

anceParser::FloatingPointTypeContext::FloatingPointTypeContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{}

size_t anceParser::FloatingPointTypeContext::getRuleIndex() const
{
    return anceParser::RuleFloatingPointType;
}

std::any anceParser::FloatingPointTypeContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitFloatingPointType(this);
    else return visitor->visitChildren(this);
}

anceParser::FloatingPointTypeContext* anceParser::floatingPointType()
{
    FloatingPointTypeContext* _localctx = _tracker.createInstance<FloatingPointTypeContext>(_ctx, getState());
    enterRule(_localctx, 126, anceParser::RuleFloatingPointType);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(700);
        _la = _input->LA(1);
        if (!(((((_la - 67) & ~0x3fULL) == 0)
               && ((1ULL << (_la - 67))
                   & ((1ULL << (anceParser::T__66 - 67)) | (1ULL << (anceParser::T__67 - 67))
                      | (1ULL << (anceParser::T__68 - 67)) | (1ULL << (anceParser::T__69 - 67))))
                      != 0)))
        {
            _errHandler->recoverInline(this);
        }
        else
        {
            _errHandler->reportMatch(this);
            consume();
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- TargetDependentTypeContext ------------------------------------------------------------------

anceParser::TargetDependentTypeContext::TargetDependentTypeContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{}

size_t anceParser::TargetDependentTypeContext::getRuleIndex() const
{
    return anceParser::RuleTargetDependentType;
}

std::any anceParser::TargetDependentTypeContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitTargetDependentType(this);
    else return visitor->visitChildren(this);
}

anceParser::TargetDependentTypeContext* anceParser::targetDependentType()
{
    TargetDependentTypeContext* _localctx = _tracker.createInstance<TargetDependentTypeContext>(_ctx, getState());
    enterRule(_localctx, 128, anceParser::RuleTargetDependentType);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(702);
        _la = _input->LA(1);
        if (!(((((_la - 63) & ~0x3fULL) == 0)
               && ((1ULL << (_la - 63))
                   & ((1ULL << (anceParser::T__62 - 63)) | (1ULL << (anceParser::T__63 - 63))
                      | (1ULL << (anceParser::T__64 - 63)) | (1ULL << (anceParser::T__70 - 63))))
                      != 0)))
        {
            _errHandler->recoverInline(this);
        }
        else
        {
            _errHandler->reportMatch(this);
            consume();
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- BooleanTypeContext ------------------------------------------------------------------

anceParser::BooleanTypeContext::BooleanTypeContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{}

size_t anceParser::BooleanTypeContext::getRuleIndex() const
{
    return anceParser::RuleBooleanType;
}

std::any anceParser::BooleanTypeContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitBooleanType(this);
    else return visitor->visitChildren(this);
}

anceParser::BooleanTypeContext* anceParser::booleanType()
{
    BooleanTypeContext* _localctx = _tracker.createInstance<BooleanTypeContext>(_ctx, getState());
    enterRule(_localctx, 130, anceParser::RuleBooleanType);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(704);
        match(anceParser::T__71);
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- CharTypeContext ------------------------------------------------------------------

anceParser::CharTypeContext::CharTypeContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{}

size_t anceParser::CharTypeContext::getRuleIndex() const
{
    return anceParser::RuleCharType;
}

std::any anceParser::CharTypeContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitCharType(this);
    else return visitor->visitChildren(this);
}

anceParser::CharTypeContext* anceParser::charType()
{
    CharTypeContext* _localctx = _tracker.createInstance<CharTypeContext>(_ctx, getState());
    enterRule(_localctx, 132, anceParser::RuleCharType);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(706);
        match(anceParser::T__72);
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- NullPointerTypeContext ------------------------------------------------------------------

anceParser::NullPointerTypeContext::NullPointerTypeContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{}

size_t anceParser::NullPointerTypeContext::getRuleIndex() const
{
    return anceParser::RuleNullPointerType;
}

std::any anceParser::NullPointerTypeContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitNullPointerType(this);
    else return visitor->visitChildren(this);
}

anceParser::NullPointerTypeContext* anceParser::nullPointerType()
{
    NullPointerTypeContext* _localctx = _tracker.createInstance<NullPointerTypeContext>(_ctx, getState());
    enterRule(_localctx, 134, anceParser::RuleNullPointerType);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(708);
        match(anceParser::T__73);
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- VoidTypeContext ------------------------------------------------------------------

anceParser::VoidTypeContext::VoidTypeContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{}

size_t anceParser::VoidTypeContext::getRuleIndex() const
{
    return anceParser::RuleVoidType;
}

std::any anceParser::VoidTypeContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitVoidType(this);
    else return visitor->visitChildren(this);
}

anceParser::VoidTypeContext* anceParser::voidType()
{
    VoidTypeContext* _localctx = _tracker.createInstance<VoidTypeContext>(_ctx, getState());
    enterRule(_localctx, 136, anceParser::RuleVoidType);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(710);
        match(anceParser::T__74);
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- CustomTypeContext ------------------------------------------------------------------

anceParser::CustomTypeContext::CustomTypeContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{}

tree::TerminalNode* anceParser::CustomTypeContext::IDENTIFIER()
{
    return getToken(anceParser::IDENTIFIER, 0);
}

size_t anceParser::CustomTypeContext::getRuleIndex() const
{
    return anceParser::RuleCustomType;
}

std::any anceParser::CustomTypeContext::accept(tree::ParseTreeVisitor* visitor)
{
    if (auto parserVisitor = dynamic_cast<anceVisitor*>(visitor)) return parserVisitor->visitCustomType(this);
    else return visitor->visitChildren(this);
}

anceParser::CustomTypeContext* anceParser::customType()
{
    CustomTypeContext* _localctx = _tracker.createInstance<CustomTypeContext>(_ctx, getState());
    enterRule(_localctx, 138, anceParser::RuleCustomType);

#if __cplusplus > 201703L
    auto onExit = finally([=, this] {
#else
    auto onExit = finally([=] {
#endif
        exitRule();
    });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(712);
        match(anceParser::IDENTIFIER);
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

bool anceParser::sempred(RuleContext* context, size_t ruleIndex, size_t predicateIndex)
{
    switch (ruleIndex)
    {
        case 26:
            return expressionSempred(antlrcpp::downCast<ExpressionContext*>(context), predicateIndex);

        default:
            break;
    }
    return true;
}

bool anceParser::expressionSempred(ExpressionContext* _localctx, size_t predicateIndex)
{
    switch (predicateIndex)
    {
        case 0:
            return precpred(_ctx, 12);
        case 1:
            return precpred(_ctx, 11);
        case 2:
            return precpred(_ctx, 10);
        case 3:
            return precpred(_ctx, 9);
        case 4:
            return precpred(_ctx, 8);
        case 5:
            return precpred(_ctx, 7);
        case 6:
            return precpred(_ctx, 6);
        case 7:
            return precpred(_ctx, 5);
        case 8:
            return precpred(_ctx, 22);
        case 9:
            return precpred(_ctx, 21);
        case 10:
            return precpred(_ctx, 20);

        default:
            break;
    }
    return true;
}

void anceParser::initialize()
{
    std::call_once(anceParserOnceFlag, anceParserInitialize);
}
